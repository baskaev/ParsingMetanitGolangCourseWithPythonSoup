<html>
 <head>
  <title>
   Combined Articles
  </title>
 </head>
 <body>
  <div class="item center menC">
   <h1>
    Введение в язык Go
   </h1>
   <h2>
    Что такое Go
   </h2>
   <div class="date">
    Последнее обновление: 17.02.2024
   </div>
   <p>
    Go представляет компилируемый статически типизированный язык программирования от компании Google. Язык Go предназначен для 
создания различного рода приложений, но прежде всего это веб-сервисы и клиент-серверные приложения. Хотя также язык обладает возможностями по работе с графикой, низкоуровневыми возможностями и т.д.
   </p>
   <p>
    Работа над языком Go началась в 2007 в недрах компании Google. Одним из авторов является Кен Томпсон, который, к слову, является и одним из 
авторов языка Си (наряду с Денисом Ритчи). 10 ноября 2009 года язык был анонсирован, а в марте 2012 года вышла версия 1.0. 
При этом язык продолжает развиваться. Текущей версией на момент написания данной статьи является версия 1.22, которая вышла в феврале 2024 года.
   </p>
   <p>
    Язык Go развивается как open source, то есть представляет поект с открытым исходным кодом, и все его коды и компилятор можно найти и использовать бесплатно. 
Официальный сайт проекта -
    <a href="https://go.dev/" rel="nofollow">
     https://go.dev/
    </a>
    , где можно много полезной информации о языке.
   </p>
   <p>
    Go является кроссплатформенным, он позволяет создавать программы под различные операционные системы - Windows, Mac OS, Linux, FreeBSD. Код обладает переносимостью: 
программы, написанные для одной из этих операционных систем, могут быть легко с перекомпиляцией перенесены на другую ОС.
   </p>
   <p>
    Основные особенности языка Go:
   </p>
   <ul>
    <li>
     <p>
      компилируемый - компилятор транслирует программу на Go в машинный код, понятный для определенной платформы
     </p>
    </li>
    <li>
     <p>
      статически типизированный
     </p>
    </li>
    <li>
     <p>
      присутствует сборщик мусора, который автоматически очищает память
     </p>
    </li>
    <li>
     <p>
      поддержка работы с сетевыми протоколами
     </p>
    </li>
    <li>
     <p>
      поддержка многопоточности и параллельного программирования
     </p>
    </li>
   </ul>
   <p>
    В настоящее время Go находит широкое применение в различных сферах. В частности, среди известных проектов, которые применяют Go, 
можно найти следующие: Google, Dropbox, Netflix, Kubernetes, Docker, Twitch, Uber, CloudFlare и ряд других.
   </p>
   <p>
    Что нужно для работы с Go? Прежде всего необходим текстовый редактор для набора кода и компилятор для преобразования кода в исполняемый файл. 
Также можно использовать специальные интегрированные среды разработки (IDE), которые поддерживают Go, например, GoLand от компании JetBrains. 
Существуют плагины для Go для других IDE, в частности, IntelliJ IDEA и Netbeans.
   </p>
   <h3>
    Установка Go
   </h3>
   <p>
    Пакет для установки компилятора можно загрузить с официального сайта
    <a href="https://go.dev/dl/" rel="nofollow">
     https://go.dev/dl/
    </a>
    .
   </p>
   <img alt="Установка компилятора для языка программирования Go" src="https://metanit.com/go/tutorial/pics/1.1.1.png" style="width:520px;"/>
   <p>
    По этому адресу пакеты установщиков для различных операционных систем. Обратите внимание на версии поддерживаемых систем. Так, на момент написания текущей статьи 
поддерживались только версии Windows 10 и выше, MacOS 10.15 и выше и Linux 2.6.32 и выше, но все версии должны быть 64-разрядными. Загрузим подходящий для нашей ОС пакет 
установщика и запустим его. Процесс установки относительно прост - надо лишь прощелкать на кнопки в окнах установщика.
   </p>
   <h4>
    Установка на Windows
   </h4>
   <p>
    Например, стартовое окно установщика для Windows:
   </p>
   <img alt="Установка компилятора Go на Windows" src="https://metanit.com/go/tutorial/pics/1.2.1.png" style="width:500px;"/>
   <p>
    После принятия лицензионного соглашения отобразится окно для выбора места установки:
   </p>
   <img alt="Путь к компилятору Go на Windows" src="https://metanit.com/go/tutorial/pics/1.3.1.png" style="width:500px;"/>
   <p>
    На Windows, например, по умолчанию используется путь "C:\Program Files\Go\". Оставим путь по умолчанию и перейдем к следующему окну, на котором нажмем на кнопку Install:
   </p>
   <img alt="Установка компилятора Go на Windows" src="https://metanit.com/go/tutorial/pics/1.4.1.png" style="width:500px;"/>
   <p>
    После успешной установки в папке установки будут установлены все файлы, необходимые для работы с Go. В частности, в подкаталоге
    <span class="ii">
     bin
    </span>
    можно найти файл
    <span class="b">
     go
    </span>
    (go.exe на Windows), который выполняет роль компилятора:
   </p>
   <img alt="Компилятор GoLang" src="https://metanit.com/go/tutorial/pics/1.5.png"/>
   <h4>
    Установка на MacOS
   </h4>
   <p>
    Установка на MacOS аналогична - с помощью мастера установки также надо последовательно нажать на кнопки:
   </p>
   <img alt="Установка компилятора Go на MacOS" src="https://metanit.com/go/tutorial/pics/1.23.png" style="width:500px;"/>
   <img alt="Установка Go на MacOS" src="https://metanit.com/go/tutorial/pics/1.24.png" style="width:500px;"/>
   <h4>
    Установка на Linux
   </h4>
   <p>
    Для Linux оф. сайт предоставляет архив. Например, в моем случае это файл
    <span class="b">
     go1.22.0.linux-amd64.tar.gz
    </span>
    . Для установки этого архива выполним команду
   </p>
   <pre class="sh">sudo rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.22.0.linux-amd64.tar.gz</pre>
   <p>
    Эта команда удаляет ранее устанавленную версию (если таковая имеется) и устанавливает новую в папку
    <span class="b">
     /usr/local/go
    </span>
    , соответственно компилятор будет располагаться в папке
    <span class="b">
     /usr/local/go/bin
    </span>
   </p>
   <p>
    После этого внесем путь к папке "/usr/local/go/bin" в переменные среды. Для этого добавим в конец файла
    <code>
     $HOME/.profile
    </code>
    или
    <code>
     /etc/profile
    </code>
    следующую строку
   </p>
   <pre class="brush:go;">export PATH=$PATH:/usr/local/go/bin</pre>
   <p>
    И для немедленного применения ее выполним команду
   </p>
   <pre class="sh">source $HOME/.profile</pre>
   <h3>
    Проверка установки Go
   </h3>
   <p>
    После установки мы можем проверить версию языка, запустив в консоли команду
    <span class="b">
     go version
    </span>
    :
   </p>
   <pre class="sh">C:\Users\eugen&gt;go version
go version go1.22.0 windows/amd64

C:\Users\eugen&gt;</pre>
  </div>
  <div class="item center menC">
   <h2>
    Первая программа
   </h2>
   <div class="date">
    Последнее обновление: 03.12.2021
   </div>
   <p>
    Создадим первую программу на языке Go. Для написания кода нам потребуется какой-нибудь текстовый редактор. Можно взять любой 
редактор, например, встроенный блокнот или популярный Notepad++ или любой другой. Для трансляции исходного кода в приложение необходим компилятор.
   </p>
   <h3>
    Создание программы
   </h3>
   <p>
    Определим на жестком диске папку для хранения файлов с исходным кодом. Допустим, в моем случае это будет папка
    <span class="b">
     C:\golang
    </span>
    . 
В этой папке создадим новый текстовый файл, который переименуем в
    <span class="b">
     hello.go
    </span>
    .
   </p>
   <img alt="Первая программа на языке Go" src="https://metanit.com/go/tutorial/pics/1.6.png"/>
   <p>
    Откроем этот файл в любом текстовом редакторе и определим в нем следующий код:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	fmt.Println("Hello Go!")
}</pre>
   <p>
    Что в этой программе делается? Программа на языке Go определяется в виде пакетов. Программный код должен быть определен в каком-то определенном пакете. Поэтому 
в самом начале файла с помощью оператора
    <span class="b">
     package
    </span>
    указывается, к какому пакету будет принадлежать файл. В данном случае это пакет main:
   </p>
   <pre class="brush:go">package main</pre>
   <p>
    Причем пакет должен называться именно main, так как именно данный пакет определяет исполняемый файл.
   </p>
   <p>
    При составлении программного кода нам может потребоваться функционал из других пакетов. В Go есть множество встроенных пакетов, которые содержат код, 
выполняющий определенные действия. Например, в нашей программе мы будем выводить сообщение на консоль. И для этого нам нужна функция
    <span class="b">
     Println
    </span>
    , 
которая определена в пакете
    <span class="b">
     fmt
    </span>
    . Поэтому второй строкой с помощью директивы
    <span class="b">
     import
    </span>
    мы подключаем этот пакет:
   </p>
   <pre class="brush:go;">import "fmt"</pre>
   <p>
    Далее идет функция main. Это главная функция любой программы на Go. По сути все, что выполняется в программе, выполняется именно функции main.
   </p>
   <p>
    Определение функции начинается со слова
    <span class="b">
     func
    </span>
    , после которого следует название функции, то есть main. 
После названия функции в скобках идет перечисление параметров. Так как функция main не принимает никаких параметров, то в данном случае указываются пустые скобки.
   </p>
   <p>
    Затем в фигурных скобках определяется тело функции main - те действия, которые собственно и выполняет функция.
   </p>
   <pre class="brush:go;">func main() {</pre>
   <p>
    В нашем случае функция выводит на консоль строку "Hello Go!". Для этого применяется функция
    <span class="b">
     Println()
    </span>
    , которая определена в пакете fmt. 
Поэтому при вызове функции вначале указывается имя пакета и через точку имя функции. А в скобках функции передается то сообщение, которое она должна выводить на консоль:
   </p>
   <pre class="brush:go;">fmt.Println("Hello Go!")</pre>
   <h3>
    Компиляция и выполнение программы
   </h3>
   <p>
    Теперь скомпилируем и выполним данную программу. Для этого необходимо передать файл с исходным кодом компилятору go.exe и указать нужную команду. 
Для этого откроем командную строку(терминал) и перейдем в ней с помощью команды
    <span class="b">
     cd
    </span>
    к папке, где храниться файл с исходным кодом
    <span class="ii">
     hello.go
    </span>
    (в моем случае это папка
    <span class="ii">
     C:\golang
    </span>
    ):
   </p>
   <div class="console">
    <pre class="consoletext">cd C:\golang</pre>
   </div>
   <p>
    Затем выполним программу с помощью следующей команды:
   </p>
   <div class="console">
    <pre class="consoletext">go run hello.go</pre>
   </div>
   <p>
    <span class="b">
     go
    </span>
    - это компилятор. Поскольку при установке путь к компилятору автоматически прописывается в переменную PATH в переменных окружения, 
то нам не надо указывать полный путь
    <span class="b">
     C:\Go\bin\go.exe
    </span>
    , а достаточно написать просто имя приложения go. Далее идет параметр
    <span class="b">
     run
    </span>
    , который говорит, что мы просто хотим выполнить программу. И в конце указывается собственно файл программы hello.go.
   </p>
   <p>
    В итоге после выполнения на консоль будет выведено сообщение "Hello Go!".
   </p>
   <img alt="Выполнение программы на языке Go" src="https://metanit.com/go/tutorial/pics/1.7.png"/>
   <p>
    Данная команды выполняет, но не компилирует программу в отдельный исполняемый файл. Для компиляции выполним другую команду:
   </p>
   <div class="console">
    <pre class="consoletext">go build hello.go</pre>
   </div>
   <p>
    После выполнения этой команды в папке с исходным файлом появится еще один файл, который будет называться hello.exe и который мы можем запускать. 
После этого опять же мы можем выполнить программу, запустив в консоли этот файл:
   </p>
   <img alt="Компиляция программы на языке Go в Windows" src="https://metanit.com/go/tutorial/pics/1.8.png"/>
  </div>
  <div class="item center menC">
   <h2>
    Go в LiteIDE
   </h2>
   <div class="date">
    Последнее обновление: 20.12.2017
   </div>
   <p>
    Использование интегрированных сред разработки (IDE) в ряде случаев упрощает управление проектом и создание приложения. Для языка Go 
одной из популярных сред разработки является LiteIDE. Это бесплатная кроссплатформенная среда, которую можно свободно загрузить себе на рабочий компьютер. 
Официальный сайт IDE -
    <a href="http://liteide.org/en/" rel="nofollow">
     http://liteide.org/en/
    </a>
    .
   </p>
   <p>
    Непосредственно загрузить все файлы данной IDE можно по ссылке:
    <a href="https://sourceforge.net/projects/liteide/files/" rel="nofollow">
     https://sourceforge.net/projects/liteide/files/
    </a>
    .
   </p>
   <img alt="LiteIDE X в GoLang" src="https://metanit.com/go/tutorial/pics/1.9.png"/>
   <p>
    На этой странице можно найти ссылку для загрузки. Причем ничего не надо устанавливать. По ссылке загружается zip-архив, который после загрузки достаточно распаковать. 
После распаковки архива в корневой папке в каталоге bin можно найти файл исполняемой программы
    <span class="b">
     liteide.exe
    </span>
    (на Windows), через который и можно запустить среду разработки:
   </p>
   <img alt="LiteIDE и язык программирования Go" src="https://metanit.com/go/tutorial/pics/1.10.png"/>
   <p>
    Запустим этот файл, и по умолчанию нам отроется стартовая странца приветствия. LiteIDE имеет локализованные версии (в том числе русифицированную версию), и через 
параметры можно переключить язык среды на любой из предложенных.
   </p>
   <p>
    Для создания нового проекта перейдем к меню
    <span class="b">
     File(Файл)
    </span>
    -&gt;
    <span class="b">
     New (Создать)
    </span>
    :
   </p>
   <img alt="Первый проект на языке Go в LiteIDE" src="https://metanit.com/go/tutorial/pics/1.11.png"/>
   <p>
    После этого отобразится окно выбора шаблона проекта:
   </p>
   <img alt="Шаблоны проектов в LiteIDE" src="https://metanit.com/go/tutorial/pics/1.12.png"/>
   <p>
    В качестве шаблона выберем
    <span class="b">
     Empty File
    </span>
    . А внизу в поле
    <span class="b">
     Name
    </span>
    укажем для файла имя
    <span class="ii">
     hello.go
    </span>
    . 
В другом поле можно увидеть путь к каталогу, где будет располагаться файл. Этот путь мы также можем изменить. И затем проект будет создан, и откроется окно, где надо будет подтвердить открытие проекта:
   </p>
   <img src="https://metanit.com/go/tutorial/pics/1.13.png"/>
   <p>
    После этого в центральной части окна программы откроется текстовый редактор. Введем в него следующий код:
   </p>
   <pre class="brush:go;">package main

import "fmt"

func main() {
	fmt.Println("Hello Go")
}</pre>
   <img alt="Создание проекта на языке Go в LiteIDE X" src="https://metanit.com/go/tutorial/pics/1.14.png"/>
   <p>
    Для сборки и запуска проекта нажмем на панели инструментов кнопку
    <span class="b">
     BR
    </span>
    . И внизу окна IDE отобразится 
поле вывода, где мы можем увидеть результат выполнения программы.
   </p>
   <p>
    Также в LiteIDE можно создавать и использовать другие типы проектов. Например, создадим проект
    <span class="b">
     Go1 Command Project
    </span>
    , который пусть называется
    <span class="ii">
     hello
    </span>
    :
   </p>
   <img src="https://metanit.com/go/tutorial/pics/1.15.png"/>
   <p>
    В результате будет создан проект, который располагается в отдельной папке и который по умолчанию состоит из двух файлов. И данный проект подобным образом мы можем запустить:
   </p>
   <img alt="Проект Go1 Command Project в LiteIDE X" src="https://metanit.com/go/tutorial/pics/1.16.png"/>
  </div>
  <div class="item center menC">
   <h2>
    Go в Visual Studio Code
   </h2>
   <div class="date">
    Последнее обновление: 21.12.2017
   </div>
   <p>
    <span class="b">
     Visual Studio Code
    </span>
    представляет кроссплатформенный подвинутый легковесный текстовый редактор от компании Microsoft, который поддерживает подсветку синтаксиса, интеллектуальную 
подсказку для разных языков программирования и многое другое. Рассмотрим, как мы можем использовать данный текстовый редактор для разработки на языке Go.
   </p>
   <p>
    Прежде всего установим данный текстовый редактор. Инсталлятор для нужной операционной системы (есть поддержка для Windows, Mac OS, Linux) 
можно найти по адресу
    <a href="https://code.visualstudio.com/" rel="nofollow">
     https://code.visualstudio.com/
    </a>
    .
   </p>
   <p>
    После установки Visual Studio Code по умолчанию не имеет никакой поддержки языка Go. Поэтому необходимо установить соответствующее расширение. Для этого 
перейдем в Visual Studio Code в меню
    <span class="b">
     View
    </span>
    -&gt;
    <span class="b">
     Extensions
    </span>
   </p>
   <img alt="GoLang в Visual Studio Code" src="https://metanit.com/go/tutorial/pics/1.17.png"/>
   <p>
    В строку поиска расширений введем "go", и нам отобразится список найденных расширений. Нам нужно установить первое в этом списке, которое имеет больше всего установок:
   </p>
   <img alt="Расширение языка Go для Visual Studio Code" src="https://metanit.com/go/tutorial/pics/1.18.png"/>
   <p>
    После установки расширения определим на жестком диске папку для хранения файлов проекта и откроем эту папку в Visual Studio Code. Открыть папку 
можно через пункт меню
    <span class="b">
     File
    </span>
    -&gt;
    <span class="b">
     Open Folder
    </span>
    . Затем создадим в VS Code новый файл, который назовем
    <span class="b">
     main.go
    </span>
    :
   </p>
   <img alt="Первый проект на языке Go в Visual Studio Code" src="https://metanit.com/go/tutorial/pics/1.19.png"/>
   <p>
    Откроем файл main.go и введем в него следующий код:
   </p>
   <pre class="brush:go;">package main

import "fmt"

func main() {
	
	fmt.Println("Hello Go")
}</pre>
   <p>
    Сохраним введенный код, нажав на комбинацию Ctrl+S.
   </p>
   <img src="https://metanit.com/go/tutorial/pics/1.20.png"/>
   <p>
    При работе с файлами go в VS Code могут появляться различные сообщения о необходимости установки дополнительных плагинов. Например, внизу окна в 
статусной строке может отображаться сообщение "Analysis Tools Missing". Можно нажать на это сообщение, и вверху VS Code отобразится список пакетов, которые желательно 
доустановить. Для их установки надо нажать на кнопку Install.
   </p>
   <p>
    Преимуществом VS Code является то, что этот редактор имеет встроенный терминал. Откроем терминал через пункт меню
    <span class="b">
     View
    </span>
    -&gt;
    <span class="b">
     Integrated Terminal
    </span>
    . После этого внизу VS Code откроется встроенный терминал. По умолчанию в нем открывается текущая папка проекта.
   </p>
   <p>
    Введем в терминал следующую команду и нажмем Enter:
   </p>
   <div class="console">
    <pre class="consoletext">go run main.go</pre>
   </div>
   <p>
    После этого во встроенном терминале мы увидим вывод программы:
   </p>
   <img alt="Запуск программы на Go в Visual Studio Code" src="https://metanit.com/go/tutorial/pics/1.21.png"/>
  </div>
  <div class="item center menC">
   <h1>
    Основы языка Go
   </h1>
   <h2>
    Структура программы
   </h2>
   <div class="date">
    Последнее обновление: 12.12.2017
   </div>
   <p>
    Программа на языке Go хранится в одном или нескольких файлах. Каждый файл с программным кодом должен принадлежать какому-нибудь пакету. И вначале каждого файла 
должно идти объявление пакета, к которому этот файл принадлежит. Пакет объявляется с помощью ключевого слова
    <span class="b">
     package
    </span>
    .
   </p>
   <p>
    В файле может использоваться функционал из других пакетов. В этом случае используемые пакеты надо импортировать с помощью ключевого слова
    <span class="b">
     import
    </span>
    . 
Импортируемые пакеты должны идти после объявления пакета для текущего файла:
   </p>
   <pre class="brush:go;">package main
import "fmt"</pre>
   <p>
    Например, в данном случае текущий файл будет находиться в пакете main. И далее он подключает пакет fmt.
   </p>
   <p>
    Причем главный пакет программы должен называться "main". Так как именно данный пакет определяет, что будет создаваться исполняемый файл приложения, который после компиляции можно будет запускать на выполнение.
   </p>
   <p>
    После подключения других пакетов располагаются объявления типов, переменных, функций, констант.
   </p>
   <p>
    При этом входной точкой в приложения является функция с именем
    <span class="b">
     main
    </span>
    . Она обязательно должна быть определена в программе. Все, что выполняется в 
программе, выполняется именно в функции main.
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	fmt.Println("Hello Go!")
}</pre>
   <p>
    Базовым элементом программы являются инструкции. Например, вызов функции
    <code>
     fmt.Println("Hello Go!")
    </code>
    представляет отдельную инструкцию. 
Каждая инструкция выполняет определенное действие и размещается на новой строке:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	fmt.Println("Hello Go!")
	fmt.Println("Hello Golang!")
	fmt.Println("Hello Go!")
}</pre>
   <p>
    Здесь функция main содержит три инструкции, которые выводит на консоль строку, и каждая из инструкций размещается на новой строке.
   </p>
   <p>
    Можно размещать несколько инструкций и на одной строке, но тогда их надо отделять точкой запятой:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	fmt.Println("Hello Go!");fmt.Println("Hello Golang!");fmt.Println("Hello Go!")
}</pre>
   <p>
    В то же время размещение инструкций на новой строке представляет более читабельный формат, поэтому более предпочтительно для использования.
   </p>
   <h3>
    Комментарии
   </h3>
   <p>
    Программа может иметь комментарии. Комментарии служат для описания действий, которые производит программа или какие-то ее части. При компиляции комментарии 
не учитываются и не оказывают никакого влияния на работу приложения. Комментарии бывают однострочными и многострочными.
   </p>
   <p>
    Однострочный комментарий располагается в одну строку после двойного слеша
    <span class="b">
     ////
    </span>
    . Все, что идет после этих символов, воспринимается 
компилятором как комментарий. Многострочный комментарий заключается между символами
    <span class="b">
     /*
    </span>
    и
    <span class="b">
     */
    </span>
    и может занимать несколько строк:
   </p>
   <pre class="brush:go;">/*
	Первая программа 
	на языке Go
*/
package main	// определение пакета для текущего файла
import "fmt"	// подключение пакета fmt

// определение функции main
func main() {
	fmt.Println("Hello Go!")	// вывод строки на консоль
}</pre>
  </div>
  <div class="item center menC">
   <h2>
    Переменные
   </h2>
   <div class="date">
    Последнее обновление: 20.12.2017
   </div>
   <p>
    Для хранения данных в программе применяются переменные. Переменная представляет именованный участок в памяти, который может хранить некоторое значение. 
Для определения переменной применяется ключевое слово
    <span class="b">
     var
    </span>
    , после которого идет имя переменной, а затем указывается ее тип:
   </p>
   <pre class="brush:go;">var имя_переменной тип_данных</pre>
   <p>
    Имя переменной представляет произвольный идентификатор, который состоит из алфавитных и цифровых символов и символа подчеркивания. При этом первым символом 
должен быть либо алфавитный символ, либо символ подчеркивания. При этом имена не должны представлять одно из ключевых слов: 
break, case, chan, const, continue, default, defer, else, fallthrough, for, func, go, goto, if, import, interface, map, package, 
range, return, select, struct, switch, type, var.
   </p>
   <p>
    Например, простейшее определение переменной:
   </p>
   <pre class="brush:go;">var hello string</pre>
   <p>
    Данная переменная называется hello и она представляет тип
    <span class="b">
     string
    </span>
    , то есть некоторую строку.
   </p>
   <p>
    Можно одновременно объявить сразу несколько переменных через запятую:
   </p>
   <pre class="brush:go;">var a, b, c string</pre>
   <p>
    В данном случае определены переменные a, b, c, которые имеют тип
    <span class="b">
     string
    </span>
    . 
В этом случае опять же в конце указывается тип данных, и все переменные принадлежат этому типу.
   </p>
   <p>
    После определения переменной ей можно присвоить какое-либо значение, которое соответствует ее типу:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	var hello string
	hello = "Hello world"
	fmt.Println(hello)
}</pre>
   <p>
    Поскольку переменная hello представляет тип string, ей можно присвоить строку. В данном случае переменная hello хранит строку "Hello world". С помощью 
функции Println значение этой переменной выводится на консоль.
   </p>
   <p>
    Также важно учитывать, что Go - регистрозависимый язык, то есть переменные с именами "hello" и "Hello" будут представлять разные переменные:
   </p>
   <pre class="brush:go;">var hello string
hello = "Hello world"
fmt.Println(Hello)	// ! Ошибка переменной Hello нет, есть переменная hello</pre>
   <p>
    Также можно сразу при объявлении переменной присвоить ей начальное значение. Такой прием называется инициализацией:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	var hello string = "Hello world"
	fmt.Println(hello)
}</pre>
   <p>
    Если мы хотим сразу определить несколько переменных и присвоить им начальные значения, то можно обернуть их в скобки:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	var (
		name string = "Tom"
		age int = 27
	)
	
	fmt.Println(name)	// Tom
	fmt.Println(age)	// 27
}</pre>
   <p>
    Отличительной особенностью переменных является то, что их значение можно многократно изменять:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	var hello string = "Hello world"
	fmt.Println(hello)	// Hello world
	
	hello = "Hello Go"
	fmt.Println(hello)	// Hello Go
	
	hello = "Go Go Go Ole Ole Ole"
	fmt.Println(hello)	// Go Go Go Ole Ole Ole
}</pre>
   <h3>
    Краткое определение переменной
   </h3>
   <p>
    Также допустимо краткое определение переменной в формате:
   </p>
   <pre class="brush:go;">имя_переменной := значение</pre>
   <p>
    После имени переменной ставится двоеточие и равно и затем указывается ее значение.
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	name := "Tom"
	fmt.Println(name)
	
}</pre>
   <p>
    В этом случае тип данных явным образом не указывается, он выводится автоматически из присваиваемого значения.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Типы данных
   </h2>
   <div class="date">
    Последнее обновление: 20.12.2017
   </div>
   <p>
    Все данные, которые хранятся в памяти, по сути представляют просто набор битов. И именно тип данных определяет, как будут интерпретироваться эти данные 
и какие операции с ними можно произодить. Язык Go является статически типизированным языком, то есть все используемые в программе данные имеют определенный тип.
   </p>
   <p>
    Go имеет ряд встроенных типов данных, а также позволяет определять свои типы. Рассмотрим базовые встроенные типы данных, 
которые мы можем использовать.
   </p>
   <h3>
    Целочисленные типы
   </h3>
   <p>
    Ряд типов представляют целые числа:
   </p>
   <ul>
    <li>
     <p>
      <span class="b">
       int8
      </span>
      : представляет целое число от -128 до 127 и занимает в памяти 1 байт (8 бит)
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       int16
      </span>
      : представляет целое число от -32768 до 32767 и занимает в памяти 2 байта (16 бит)
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       int32
      </span>
      : представляет целое число от -2147483648 до 2147483647 и занимает 4 байта (32 бита)
     </p>
     <li>
      <p>
       <span class="b">
        int64
       </span>
       : представляет целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт (64 бита)
      </p>
     </li>
     <li>
      <p>
       <span class="b">
        uint8
       </span>
       : представляет целое число от 0 до 255 и занимает 1 байт
      </p>
     </li>
     <li>
      <p>
       <span class="b">
        uint16
       </span>
       : представляет целое число от 0 до 65535 и занимает 2 байта
      </p>
     </li>
     <li>
      <p>
       <span class="b">
        uint32
       </span>
       : представляет целое число от 0 до 4294967295 и занимает 4 байта
      </p>
     </li>
     <li>
      <p>
       <span class="b">
        uint64
       </span>
       : представляет целое число от 0 до 18 446 744 073 709 551 615 и занимает 8 байт
      </p>
     </li>
     <li>
      <p>
       <span class="b">
        byte
       </span>
       : синоним типа
       <code>
        uint8
       </code>
       , представляет целое число от 0 до 255 и занимает 1 байт
      </p>
     </li>
     <li>
      <p>
       <span class="b">
        rune
       </span>
       : синоним типа
       <code>
        int32
       </code>
       , представляет целое число от -2147483648 до 2147483647 и занимает 4 байта
      </p>
     </li>
     <li>
      <p>
       <span class="b">
        int
       </span>
       : представляет целое число со знаком, которое в зависимости о платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо 
int32, либо int64.
      </p>
     </li>
     <li>
      <p>
       <span class="b">
        uint
       </span>
       : представляет целое беззнаковое число только без знака, которое, аналогично типу int, в зависимости о платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо 
uint32, либо uint64.
      </p>
     </li>
    </li>
   </ul>
   <p>
    Здесь несложно запомнить, что есть типы со знаком (то есть которые могут быть отрицательными) и есть безнаковые положительные типы, которые начинаются на префикс u (uint32). Ну и также есть byte - синоним для uint8 и rune - синоним для int32.
   </p>
   <p>
    Стоит отметить типы int и uint. Они имеют наиболее эффективный размер для определенной платформы (32 или 64 бита). Это наиболее используемый тип для представления целых чисел в программе. Причем различные 
компиляторы могут предоставлять различный размер для этих типов даже для одной и той же платформы.
   </p>
   <p>
    Примеры определения переменных, которые представляют целочисленные типы:
   </p>
   <pre class="brush:go;">var a int8 = -1
var b uint8 = 2
var c byte = 3	// byte - синоним типа uint8
var d int16 = -4
var f uint16 = 5
var g int32 = -6
var h rune = -7		// rune - синоним типа int32
var j uint32 = 8
var k int64 = -9
var l uint64 = 10
var m int = 102
var n uint = 105</pre>
   <h3>
    Числа с плавающей точкой
   </h3>
   <p>
    Для представления дробных чисел есть два типа:
   </p>
   <ul>
    <li>
     <p>
      <span class="b">
       float32
      </span>
      : представляет число с плавающей точкой от 1.4*10
      <sup>
       -45
      </sup>
      до 3.4*10
      <sup>
       38
      </sup>
      (для положительных). 
Занимает в памяти 4 байта (32 бита)
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       float64
      </span>
      : представляет число с плавающей точкой от 4.9*10
      <sup>
       -324
      </sup>
      до 1.8*10
      <sup>
       308
      </sup>
      (для положительных) и 
занимает 8 байт.
     </p>
    </li>
   </ul>
   <p>
    Тип float32 обеспечивает шесть десятичных цифр точности, в то время как точность, обеспечиваемая типом float64, составляет около 15 цифр
   </p>
   <p>
    Примеры использования типов float32 и float64:
   </p>
   <pre class="brush:go;">var f float32 = 18
var g float32 = 4.5
var d float64 = 0.23
var pi float64 = 3.14
var e float64 = 2.7</pre>
   <p>
    В качестве разделителя между целой и дробной частью применяется точка.
   </p>
   <h3>
    Комплексные числа
   </h3>
   <p>
    Существуют отдельные типы для представления комплексных чисел:
   </p>
   <ul>
    <li>
     <p>
      <span class="b">
       complex64
      </span>
      : комплексное число, где вещественная и мнимая части представляют числа float32
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       complex128
      </span>
      : комплексное число, где вещественная и мнимая части представляют числа float64
     </p>
    </li>
   </ul>
   <p>
    Пример использования:
   </p>
   <pre class="brush:go;">var f complex64 = 1+2i
var g complex128 = 4+3i</pre>
   <h3>
    Тип bool
   </h3>
   <p>
    Логический тип или тип
    <span class="b">
     bool
    </span>
    может иметь одно из двух значений:
    <span class="b">
     true
    </span>
    (истина) или
    <span class="b">
     false
    </span>
    (ложь).
   </p>
   <pre class="brush:go;">var isAlive bool = true
var isEnabled bool = false</pre>
   <h3>
    Строки
   </h3>
   <p>
    Строки представлены типом
    <span class="b">
     string
    </span>
    . В Go строке соответствует строковый литерал - последовательность символов, заключенная в 
двойные кавычки:
   </p>
   <pre class="brush:go;">var name string = "Том Сойер"</pre>
   <p>
    Кроме обычных символов строка может содержать специальные последовательности (управляющие последовательности), которые начинаются с обратного слеша \. Наиболее 
распространенные последовательности:
   </p>
   <ul>
    <li>
     <p>
      <span class="b">
       \n
      </span>
      : переход на новую строку
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       \r
      </span>
      : возврат каретки
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       \t
      </span>
      : табуляция
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       \"
      </span>
      : двойная кавычка внутри строк
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       \\
      </span>
      : обратный слеш
     </p>
    </li>
   </ul>
   <h3>
    Значение по умолчанию
   </h3>
   <p>
    Если переменной не присвоено значение, то она имеет значение по умолчанию, которое определено для ее типа. Для числовых типов это число 0, для логического типа - false, 
для строк - ""(пустая строка).
   </p>
   <h3>
    Неявная типизация
   </h3>
   <p>
    При определении переменной мы можем опускать тип в том случае, если мы явно инициализируем переменную каким-нибудь значением:
   </p>
   <pre class="brush:go;">var name = "Tom"</pre>
   <p>
    В этом случае компилятор на основании значения неявно выводит тип переменной. Если присваивается строка, то то соответственно переменная будет представлять тип string, 
если присваивается целое число, то переменная представляет тип int и т.д.
   </p>
   <p>
    То же самое по сути происходит при кратком определении переменной, когда также явным образом не указывается тип данных:
   </p>
   <pre class="brush:go;">name := "Tom"</pre>
   <p>
    При этом стоит учитывать, что если мы не указываем у переменной тип, то ей обязательно надо присвоить некоторое начальное значение. Объявление 
переменной одновременно без указания типа данных и начального значения будет ошибкой:
   </p>
   <pre class="brush:go;">var name	// ! Ошибка</pre>
   <p>
    Надо либо указать тип данных (в этом случае переменная будет иметь значение по умолчанию):
   </p>
   <pre class="brush:go;">var name string</pre>
   <p>
    Либо указать начальное значение, на основании которого выводится тип данных:
   </p>
   <pre class="brush:go;">var name = "Tom"</pre>
   <p>
    Либо и то, и другое одновременно:
   </p>
   <pre class="brush:go;">var name string = "Tom"</pre>
   <p>
    Неявная типизация нескольких переменных:
   </p>
   <pre class="brush:go;">var (
		name = "Tom"
		age = 27
)</pre>
   <p>
    или так:
   </p>
   <pre class="brush:go;">var name, age = "Tom", 27</pre>
  </div>
  <div class="item center menC">
   <h2>
    Константы
   </h2>
   <div class="date">
    Последнее обновление: 18.12.2017
   </div>
   <p>
    Константы, как и переменные, хранят некоторые данные, но в отличие от переменных значения констант нельзя изменить, они устанавливаются один раз. 
Вычисление констант производится во время компиляции. Благодаря этому уменьшается количество работы, которую необходимо произвести во время выполнения, упрощается поиск ошибок, 
связанных с константами (так как некоторые из них можно обнаружить на момент компиляции).
   </p>
   <p>
    Для определения констант применяется ключевое слово
    <span class="b">
     const
    </span>
    :
   </p>
   <pre class="brush:go;">const pi float64 = 3.1415</pre>
   <p>
    И в отличие от переменной мы не можем изменить значение константы. А если и попробуем это сделать, то при компиляции мы получим ошибку:
   </p>
   <pre class="brush:go;">const pi float64 = 3.1415
pi = 2.7182				// ! Ошибка</pre>
   <p>
    В одном определении можно объявить разу несколько констант:
   </p>
   <pre class="brush:go;">const (
	pi float64 = 3.1415
	e float64 = 2.7182
)</pre>
   <p>
    или так:
   </p>
   <pre class="brush:go;">const pi, e = 3.1415, 2.7182</pre>
   <p>
    Если у константы не указан тип, то он выводится неявно на основании того значения, которым инициализируется константа:
   </p>
   <pre class="brush:go;">const n = 5		//  тип int</pre>
   <p>
    В то же время необходимо обязательно инициализировать константу начальным значением при ее объявлении. Например, следующие определения констант 
являются недопустимыми, так как они не инициализируются:
   </p>
   <pre class="brush:go;">const d
const n int</pre>
   <p>
    Если определяется последовательность констант, то инициализацию значением можно опустить для всех констант, кроме первой. В этом случае константа без значения 
полчит значение предыдущей константы:
   </p>
   <pre class="brush:go;">const (
	a = 1
	b
	c
	d = 3
	f
)
fmt.Println(a, b, c, d, f)		// 1, 1, 1, 3, 3</pre>
   <p>
    Константы можно инициализировать только константными значениями, например, литералами типа чисел или строк, или значениями других констант. 
Но инициализировать константу значением переменной мы не можем:
   </p>
   <pre class="brush:go;">var m int = 7
// const k = m		// ! Ошибка: m - переменная
const s = 5		// Норм: 5 - числовая константа
const n = s		// Норм: s - константа</pre>
  </div>
  <div class="item center menC">
   <h2>
    Арифметические операции
   </h2>
   <div class="date">
    Последнее обновление: 18.12.2017
   </div>
   <p>
    Язык Go поддерживает все основные арифметические операции, которые производятся над числами. Значения, которые участвуют в операции, называются операндами. Результатом операции 
также является число. Список поддерживаемых арифметических операций:
   </p>
   <ul>
    <li>
     <p>
      +
     </p>
     <p>
      Операция сложения возвращает сумму двух чисел:
     </p>
     <pre class="brush:go;">package main
import "fmt"

func main() {
	var a = 4
	var b = 6
	var c = a + b
	fmt.Println(c)		// 10
}</pre>
    </li>
    <li>
     <p>
      -
     </p>
     <p>
      Операция вычитания возвращает разность двух чисел:
     </p>
     <pre class="brush:go;">package main
import "fmt"

func main() {
	var a = 4
	var b = 6
	var c = a - b
	fmt.Println(c)		// -2
}</pre>
    </li>
    <li>
     <p>
      *
     </p>
     <p>
      Операция умножения возвращает произведение двух чисел:
     </p>
     <pre class="brush:go;">var a = 4
var b = 6
var c = a * b	// 24</pre>
    </li>
    <li>
     <p>
      /
     </p>
     <p>
      Операция деления двух чисел:
     </p>
     <pre class="brush:go;">var a int = 10
var b int = 4
var c int = a / b
fmt.Println(c)		// 2
	
var k float32 = 10
var l float32 = 4
var m float32 = k / l
fmt.Println(m)		// 2.5</pre>
     <p>
      При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат 
присваивается переменной типа float32/float64:
     </p>
     <pre class="brush:go;">var m float32 = 10 / 4		// 2</pre>
     <p>
      Результат представлял вещественное число, один из операндов также должен представлять вещественное число:
     </p>
     <pre class="brush:go;">var m float32 = 10 / 4.0		// 2.5</pre>
    </li>
    <li>
     <p>
      %
     </p>
     <p>
      Возвращает остаток от деления (в этой операции могут принимать участие только целочисленные операнды):
     </p>
     <pre class="brush:go;">var c int = 35 % 3		// 2 (35 - 33 = 2)</pre>
    </li>
    <li>
     <p>
      Постфиксный инкремент (x++). Увеличивает значение переменной на единицу:
      <p>
       <pre class="brush:go;">var a int = 8
a++
fmt.Println(a)		// 9</pre>
      </p>
     </p>
    </li>
    <li>
     <p>
      Постфиксный декремент (x--). Уменьшает значение переменной на единицу:
      <p>
       <pre class="brush:go;">var a int = 8
a--
fmt.Println(a)		// 7</pre>
      </p>
     </p>
    </li>
   </ul>
  </div>
  <div class="item center menC">
   <h2>
    Условные выражения
   </h2>
   <div class="date">
    Последнее обновление: 18.12.2017
   </div>
   <p>
    Условные выражения представляют логические операции и операции отношения. Они представляют некоторое условие и возвращают значение типа bool:
    <code>
     true
    </code>
    (если условие истинно) или
    <code>
     false
    </code>
    (если условие ложно).
   </p>
   <h3>
    Операции отношения
   </h3>
   <p>
    Операции отношения позволяют сравнить два значения. В языке Go есть следующие операции отношения:
   </p>
   <ul>
    <li>
     <p>
      <span class="b">
       ==
      </span>
     </p>
     <p>
      Операция "равно". Возвращает true, если оба операнда равны, и false, если они не равны:
     </p>
     <pre class="brush:go;">package main
import "fmt"

func main() {
	var a int = 8
	var b int = 3
	var c bool = a == b
	fmt.Println(c)		// false
}</pre>
    </li>
    <li>
     <p>
      <span class="b">
       &gt;
      </span>
     </p>
     <p>
      Операция "больше чем". Возвращает true, если первый операнд больше второго, и false, если первый операнд меньше второго:
     </p>
     <pre class="brush:go;">var a int = 8
var b int = 3
var c bool = a &gt; b	// true</pre>
    </li>
    <li>
     <p>
      <span class="b">
       &lt;
      </span>
     </p>
     <p>
      Операция "меньше чем". Возвращает true, если первый операнд меньше второго, и false, если первый операнд больше второго:
     </p>
     <pre class="brush:c;">var a int = 8
var b int = 3
var c bool = a &lt; b	// false</pre>
    </li>
    <li>
     <p>
      <span class="b">
       &lt;=
      </span>
     </p>
     <p>
      Операция "меньше или равно". Возвращает true, если первый операнд меньше или равен второму, и false, если первый операнд больше второго:
     </p>
     <pre class="brush:go;">var a int = 8
var b int = 3
var c bool = a &lt;= b	// false</pre>
    </li>
    <li>
     <p>
      <span class="b">
       &gt;=
      </span>
     </p>
     <p>
      Операция "больше или равно". Возвращает true, если первый операнд больше или равен второму, и false, если первый операнд меньше второго:
     </p>
     <pre class="brush:go;">var a int = 8
var b int = 3
var c bool = a &gt;= b	// true</pre>
    </li>
    <li>
     <p>
      <span class="b">
       !=
      </span>
     </p>
     <p>
      Операция "не равно". Возвращает true, если первый операнд не равен второму, и false, если оба операнда равны:
     </p>
     <pre class="brush:go;">var a int = 8
var b int = 3
var c bool = a != b	// true
var d bool = a != 8	// false</pre>
    </li>
   </ul>
   <p>
    Как правило, операции отношения применяются в условных конструкциях типа if...else, которые мы далее рассмотрим.
   </p>
   <h3>
    Логические операции
   </h3>
   <p>
    Логические операции сравнивают два условия. Как правило, они применяются к отношениям и объединяют несколько операций отношения. К логическим операциям относят следующие:
   </p>
   <ul>
    <li>
     <p>
      <span class="b">
       !
      </span>
      (операция отрицания)
     </p>
     <p>
      Инвертирует значение. Если операнд равен true, то возвращает false, иначе возвращает true.
     </p>
     <pre class="brush:go;">var a bool = true
var b bool = !a		//false
var c bool = !b		// true</pre>
    </li>
    <li>
     <p>
      <span class="b">
       &amp;&amp;
      </span>
      (конъюнкция, логическое умножение)
     </p>
     <p>
      Возвращает true, если оба операнда не равны false. Возвращает false, если хотя бы один операнд равен false.
     </p>
     <pre class="brush:go;">var b bool = 4 &gt; 5 &amp;&amp; 6 &gt; 8		//false
var c bool = 3 &lt;= 5 &amp;&amp; 10 &gt; 8	// true</pre>
    </li>
    <li>
     <p>
      <span class="b">
       ||
      </span>
      (дизъюнкция, логическое сложение)
     </p>
     <p>
      Возвращает true, если хотя бы один операнд не равен false. Возвращает false, если оба операнда равны false.
     </p>
     <pre class="brush:go;">var b bool = 4 &gt; 5 || 6 &gt; 8		//false
var c bool = 3 == 5	|| 10 &gt; 8	// true</pre>
    </li>
   </ul>
  </div>
  <div class="item center menC">
   <h2>
    Поразрядные операции
   </h2>
   <div class="date">
    Последнее обновление: 18.12.2017
   </div>
   <p>
    Поразрядные операции выполняются над отдельными разрядами чисел в бинарном представлении. Например, число пять в двоичной системе имеет три разряда: 101, а число восемь - четыре разряда: 1000.
   </p>
   <h3>
    Операции сдвига
   </h3>
   <p>
    И операции сдвига позволяют сдвинуть двоичное представление числа на несколько разрядов вправо или влево. Операции сдвига применяются только к целочисленным операндам. Есть две операции:
   </p>
   <ul>
    <li>
     <p>
      <span class="b">
       &lt;&lt;
      </span>
     </p>
     <p>
      Сдвигает битовое представление числа, представленного первым операндом, влево на определенное количество разрядов, которое задается вторым операндом.
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       &gt;&gt;
      </span>
     </p>
     <p>
      Сдвигает битовое представление числа вправо на определенное количество разрядов.
     </p>
    </li>
   </ul>
   <p>
    Применение операций:
   </p>
   <pre class="brush:go;">var b int = 2 &lt;&lt; 2;			// 10  на два разрядов влево = 1000 - 8
var c int = 16 &gt;&gt; 3;			// 10000 на три разряда вправо = 100 - 2</pre>
   <p>
    Число 2 в двоичном представлении 10. Если сдвинуть число 10 на два разряда влево, то получится 1000, что в десятичной системе равно число 8.
   </p>
   <p>
    Число 16 в двоичном представлении 10000. Если сдвинуть число 10000 на три разряда вправо (три последних разряда отбрасываются), то получится 10, что в 
десятичной системе представляет число 2.
   </p>
   <h3>
    Поразрядные операции
   </h3>
   <p>
    Поразрядные операции также проводятся только над разрядами целочисленных операндов:
   </p>
   <ul>
    <li>
     <p>
      <span class="b">
       &amp;
      </span>
      : поразрядная конъюнкция (операция И или поразрядное умножение). Возвращает 1, если оба из соответствующих разрядов обоих чисел равны 1. Возвращает 0, если разряд хотя бы одного числа равен 0
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       |
      </span>
      : поразрядная дизъюнкция (операция ИЛИ или поразрядное сложение). Возвращает 1, если хотя бы один из соответствующих разрядов обоих чисел равен 1
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       ^
      </span>
      : поразрядное исключающее ИЛИ. Возвращает 1, если только один из соответствующих разрядов обоих чисел равен 1
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       &amp;^
      </span>
      : сброс бита (И НЕ). В выражении
      <code>
       z = x &amp;^ y
      </code>
      каждый бит z равен 0, если соответствующий бит y равен 1. Если бит в y равен 0, то берется значение соответствующего бита из x.
     </p>
    </li>
   </ul>
   <p>
    Применение операций:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	var a int = 5 | 2;			// 101 | 010 = 111  - 7
	var b int = 6 &amp; 2;			// 110 &amp; 010 = 10  - 2
	var c int = 5 ^ 2;			// 101 ^ 010 = 111 - 7
	var d int = 5 &amp;^ 6;			// 101 &amp;^ 110 = 001 - 1
}</pre>
   <p>
    Например, выражение
    <code>
     5 | 2
    </code>
    равно 7. Число 5 в двоичной записи равно 101, а число 2 - 10 или 010. Сложим соответствующие разряды обоих чисел. При сложении если хотя бы 
один разряд равен 1, то сумма обоих разрядов равна 1. Поэтому получаем:
   </p>
   <table>
    <tr>
     <td>
      1
     </td>
     <td>
      0
     </td>
     <td>
      1
     </td>
    </tr>
    <tr>
     <td>
      0
     </td>
     <td>
      1
     </td>
     <td>
      0
     </td>
    </tr>
    <tr>
     <td>
      1
     </td>
     <td>
      1
     </td>
     <td>
      1
     </td>
    </tr>
   </table>
   <p>
    В итоге получаем число 111, что в десятичной записи представляет число 7.
   </p>
   <p>
    Возьмем другое выражение
    <code>
     6 &amp; 2
    </code>
    . Число 6 в двоичной записи равно 110, а число 2 - 10 или 010. Умножим соответствующие разряды 
обоих чисел. Произведение обоих разрядов равно 1, если оба этих разряда равны 1. Иначе произведение равно 0. Поэтому получаем:
   </p>
   <table>
    <tr>
     <td>
      1
     </td>
     <td>
      1
     </td>
     <td>
      0
     </td>
    </tr>
    <tr>
     <td>
      0
     </td>
     <td>
      1
     </td>
     <td>
      0
     </td>
    </tr>
    <tr>
     <td>
      0
     </td>
     <td>
      1
     </td>
     <td>
      0
     </td>
    </tr>
   </table>
   <p>
    Получаем число 010, что в десятичной системе равно 2.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Массивы
   </h2>
   <div class="date">
    Последнее обновление: 20.12.2017
   </div>
   <p>
    Массивы представляют последовательность элементов определенного типа. Массив определяется следующим способом:
   </p>
   <pre class="brush:go;">var numbers [число_элементов]тип_элементов</pre>
   <p>
    Например, массив из пяти элементов типа int:
   </p>
   <pre class="brush:go;">var numbers [5]int</pre>
   <p>
    При таком определении все элементы массива инициализируются значениями по умолчанию. Но также можно инициализировать элементы массива другими значениями:
   </p>
   <pre class="brush:go;">var numbers [5]int = [5]int{1,2,3,4,5}</pre>
   <p>
    Значения передаются в фигурных скобках через запятую. При этом значений не может быть больше длины массива. В данном случае длина массива равна 5, поэтому нельзя в фигурных скобках определить больше пяти элементов. 
Но можно определить меньше элементов:
   </p>
   <pre class="brush:go;">var numbers [5]int = [5]int{1,2}
fmt.Println(numbers)	// [1 2 0 0 0]</pre>
   <p>
    В этом случае элементы, для которых не указано значение, будут иметь значение по умолчанию.
   </p>
   <p>
    Также можно применять сокращенное определение переменной массива:
   </p>
   <pre class="brush:go;">numbers := [5]int{1,2,3,4,5}</pre>
   <p>
    Если в квадратных скобках вместо длины указано троеточие, то длина массива определяется, исходя из количества переданных ему элементов:
   </p>
   <pre class="brush:go;">var numbers = [...]int{1,2,3,4,5}	// длина массива 5
numbers2 := [...]int{1,2,3}			// длина массива 3
fmt.Println(numbers)				// [1 2 3 4 5]
fmt.Println(numbers2)			// [1 2 3]</pre>
   <p>
    При этом длина массива является частью его типа. И, к примеру, следующие два массива представляют разные типы данных, хотя они и хранят данные одного типа:
   </p>
   <pre class="brush:go;">var numbers [3]int = [3]int{1, 2, 3}
var numbers2 [4]int = [4]int{1, 2, 3, 4}
numbers = numbers2	// ! Ошибка</pre>
   <p>
    И в данном случае при присвоении мы получим ошибку, так как данные одного типа пытаемся передать переменной другого типа.
   </p>
   <h3>
    Индексы
   </h3>
   <p>
    Для обращения к элементам массива применяются индексы - номера элементов. При этом нумерация начинается с нуля, то есть первый элемент будет 
иметь индекс 0. Индекс указывается в квадратных скобках. По индексу можно получить значение элемента, либо изменить его:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	var numbers [5]int = [5]int{1,2,3,4,5}
	fmt.Println(numbers[0])		// 1
	fmt.Println(numbers[4])		// 5
	numbers[0] = 87
	fmt.Println(numbers[0])		// 87
}</pre>
   <p>
    Индексы в массиве фактически выступают в качестве ключей, по которым можно обратиться к соответствующему значению. И в прицнипе мы можем явным образом 
указать, какому ключу какое значение будет соответствовать. При этому числовые ключи необязательно располагать в порядке возрастания:
   </p>
   <pre class="brush:go;">colors := [3]string{2: "blue", 0: "red", 1: "green"}
fmt.Println(colors[2])		// blue</pre>
  </div>
  <div class="item center menC">
   <h2>
    Условные конструкции
   </h2>
   <div class="date">
    Последнее обновление: 20.12.2017
   </div>
   <p>
    Условные конструкции проверяют истинность некоторого условия и в зависимости от результатов проверки позволяют направить ход программы по одному из путей.
   </p>
   <h3>
    if...else
   </h3>
   <p>
    Конструкция if принимает условие - выражение, которое возвращает значение типа
    <span class="b">
     bool
    </span>
    . И если это условие истинно, то выполняется последующий блок инструкций.
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	a := 6
	b := 7
	if a &lt; b {
		fmt.Println("a is less than b")
	}
}</pre>
   <p>
    Условие ставится после оператора if. В данном случае проверяется, меньше ли значение переменной a чем значние переменой b. Поскольку в данном случае 
значение переменной a действительно меньше значения переменной b, то есть условие возвращает true, то будет выполнять последующий блок кода, который выводит на консоль сообщение.
   </p>
   <p>
    Если необходимо задать альтернативную логику, которая выполняется, в случае если условие неверно, то добавляется выражение else:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	a := 6
	b := 7
	if a &lt; b {
		fmt.Println("a меньше b")
	}else{
		fmt.Println("a больше b")
	}
}</pre>
   <p>
    Таким образом, если условное выражение после оператора if истинно, то выполняется блок после if, если ложно - выполняется блок после else.
   </p>
   <p>
    Если необходимо проверить несколько альтернативных вариантов, то можно добавить выражения
    <span class="b">
     else if
    </span>
    :
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	a := 8
	b := 8
	if a &lt; b {
		fmt.Println("a меньше b")
	}else if a &gt; b{
		fmt.Println("a больше b")
	} else{
		fmt.Println("a равно b")
	}
}</pre>
   <p>
    Таким образом, если выражение после if истинно, то срабатывает блок if. Иначе проверяется выражение после else if. Если оно истинно, то выполняется 
блок else if. Если оно ложно, то выполняется блок else.
   </p>
   <p>
    Выражений else if может быть множество:
   </p>
   <pre class="brush:go;">if a ==9 {
	fmt.Println("a = 9")
}else if a == 8{
	fmt.Println("a = 8")
} else if a == 7{
	fmt.Println("a == 7")
}</pre>
   <h3>
    switch
   </h3>
   <p>
    Конструкция
    <span class="b">
     switch
    </span>
    проверяет значение некоторого выражения. С помощью операторов
    <span class="b">
     case
    </span>
    определяются 
значения для сравнения. Если значение после оператора case совпадает со значением выражения из switch, то выполняется код данного блока case.
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	a := 8
	switch(a) {
		case 9: 
			fmt.Println("a = 9")
		case 8: 
			fmt.Println("a = 8")
		case 7: 
			fmt.Println("a = 7")
	}
}</pre>
   <p>
    В качестве выражения конструкция switch использует переменную a. Ее значение последовательно сравнивается со значениями после операторов case. Поскольку 
переменная a равна 8, то будет выполняться блок
    <code>
     case 8: fmt.Println("a = 8")
    </code>
    . Остальные блоки case не выполняются.
   </p>
   <p>
    При этом после оператора switch мы можем указывать любое выражение, которое возвращает значение. Например, операцию сложения:
   </p>
   <pre class="brush:go;">a := 7
switch(a + 2) {
	case 9: 
		fmt.Println("9")
	case 8: 
		fmt.Println("8")
	case 7: 
		fmt.Println("7")
}</pre>
   <p>
    Также конструкция switch может содержать необязательных блок
    <span class="b">
     default
    </span>
    , который выполняется, если ни один из операторов case 
не содержит нужного значения:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	a := 87
	switch(a) {
		case 9: 
			fmt.Println("a = 9")
		case 8: 
			fmt.Println("a = 8")
		case 7: 
			fmt.Println("a = 7")
		default: 
			fmt.Println("значение переменной a не определено")
	}
}</pre>
   <p>
    Также можно указывать после оператора case сразу несколько значений:
   </p>
   <pre class="brush:go;">a := 5
switch(a) {
	case 9: fmt.Println("a = 9")
	case 8: fmt.Println("a = 8")
	case 7: fmt.Println("a = 7")
	case 6, 5, 4: 
		fmt.Println("a = 6 или 5 или 4, но это не точно")
	default: 
		fmt.Println("значение переменной a не определено")
}</pre>
  </div>
  <div class="item center menC">
   <h2>
    Циклы
   </h2>
   <div class="date">
    Последнее обновление: 20.12.2017
   </div>
   <p>
    Циклы позволяют в зависимости от определенного условия выполнять некоторые действия множество раз. Фактически в Go есть только один цикл - цикл for, 
который может принимать разные формы. Этот цикл имеет следующее формальное определение:
   </p>
   <pre class="brush:go;">for [инициализация счетчика]; [условие]; [изменение счетчика]{
    // действия
}</pre>
   <p>
    Например, выведем с помощью цикла квадраты чисел:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	for i := 1; i &lt; 10; i++{
		fmt.Println(i * i)
	}
}</pre>
   <p>
    Объявление цикла for разбивается на три части. Вначале идет инициализация счетчика:
    <code>
     i := 1
    </code>
    . Фактически она представляет 
объявление переменной, которая будет использоваться внутри цикла. В данном случае это счетчик i, начальное значение которого равно 1.
   </p>
   <p>
    Вторая часть представляет условие:
    <code>
     i &lt; 10
    </code>
    . Пока это условие истинно, то есть возвращает true, будет продолжаться цикл.
   </p>
   <p>
    Третья часть представляет изменение (увеличение) счетчика на единицу.
   </p>
   <p>
    В теле цикла на консоль выводится квадрат числа i.
   </p>
   <p>
    Таким образом, цикл сработает 9 раз, пока значение i не станет равным 10. И каждый раз это значение будет увеличиваться на 1. Каждый отдельный проход цикла называется 
итерацией. То есть в данном случае будет 9 итераций. В итоге мы получим следующий консольный вывод:
   </p>
   <div class="console">
    <pre class="consoletext">1
4
9
16
25
36
49
64
81</pre>
   </div>
   <p>
    Нам необязательно указывать все условия при объявлении цикла. Например, можно вынести объявление переменной вовне:
   </p>
   <pre class="brush:go;">var i = 1
for ; i &lt; 10; i++{
	fmt.Println(i * i)
}</pre>
   <p>
    Можно убрать изменение счетчика в само тело цикла и оставить только условие:
   </p>
   <pre class="brush:go;">var i = 1
for ; i &lt; 10;{
	fmt.Println(i * i)
	i++
}</pre>
   <p>
    Если цикл использует только условие, то его можно сократить следующим образом:
   </p>
   <pre class="brush:go;">var i = 1
for i &lt; 10{
	fmt.Println(i * i)
	i++
}</pre>
   <h3>
    Вложенные циклы
   </h3>
   <p>
    Циклы могут быть вложенными, то есть располагаться внутри других циклов. Например, выведем на консоль таблицу умножения:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	for i := 1; i &lt; 10; i++{
		for j := 1; j &lt; 10; j++{
			fmt.Print(i * j, "\t")
		}
		fmt.Println()
	}
}</pre>
   <div class="console">
    <pre class="consoletext">1	2	3	4	5	6	7	8	9	
2	4	6	8	10	12	14	16	18	
3	6	9	12	15	18	21	24	27	
4	8	12	16	20	24	28	32	36	
5	10	15	20	25	30	35	40	45	
6	12	18	24	30	36	42	48	54	
7	14	21	28	35	42	49	56	63	
8	16	24	32	40	48	56	64	72	
9	18	27	36	45	54	63	72	81</pre>
   </div>
   <h3>
    Перебор массивов
   </h3>
   <p>
    Для перебора массивов можно использовать следующую форму цикла for:
   </p>
   <pre class="brush:go;">for индекс, значение := range массив{
	// действия
}</pre>
   <p>
    При переборе мы можем по отдельности получить индекс элемента в массиве и значение этого элемента. Например, перебирем массив строк:
   </p>
   <pre class="brush:go;">var users = [3]string{"Tom", "Alice", "Kate"}
for index, value := range users{
	fmt.Println(index, value)
}</pre>
   <p>
    Консольный вывод:
   </p>
   <div class="console">
    <pre class="consoletext">0 Tom
1 Alice
2 Kate</pre>
   </div>
   <p>
    Если мы не планируем использовать значения или индексы элементов, то мы можем вместо них указать прочерк. Например, нам не нужны индексы:
   </p>
   <pre class="brush:go;">for _, value := range users{
	fmt.Println(value)
}</pre>
   <p>
    Но также для перебора массива можно использовать и стандартную версию цикла for:
   </p>
   <pre class="brush:go;">var users = [3]string{"Tom", "Alice", "Kate"}
for i:= 0; i &lt; len(users); i++{
	fmt.Println(users[i])
}</pre>
   <p>
    В данном случае счетчик i играет роль индекса. Цикл выполняется, пока счетчик i не станет равным длине массива, которую можно получить с помощью 
функции
    <span class="b">
     len()
    </span>
   </p>
   <h3>
    Операторы break и continue
   </h3>
   <p>
    Может возникнуть ситуация, когда нам надо при определенных условиях завершить текущую итерацию цикла, не выполнять все инструкции цикла, а 
сразу перейти к следующей итерации. В этом случае можно использовать оператор
    <span class="b">
     continue
    </span>
    . Например, в массиве могу быть, как положительные, так и отрицательные числа. 
Допустим, нам нужна сумма только положительных чисел, поэтому, если нам встретится отрицательное число, мы можем просто перейти к следующей итерации с помощью continue:
   </p>
   <pre class="brush:go;">var numbers = [10]int{1, -2, 3, -4, 5, -6, -7, 8, -9, 10}
var sum = 0

for _, value := range numbers{
	if value &lt; 0{
		continue		// переходим к следующей итерации
	}
	sum += value
}
fmt.Println("Sum:", sum) 	// Sum: 27</pre>
   <p>
    Оператор
    <span class="b">
     break
    </span>
    полностью осуществляет выход из цикла:
   </p>
   <pre class="brush:go;">var numbers = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
var sum = 0

for _, value := range numbers{
	if value &gt; 4{
		break		// если число больше 4 выходим из цикла
	}
	sum += value
}
fmt.Println("Sum:", sum) 	// Sum: 10</pre>
  </div>
  <div class="item center menC">
   <h2>
    Функции и их параметры
   </h2>
   <div class="date">
    Последнее обновление: 20.12.2017
   </div>
   <p>
    Функция представляет блок операторов, которые все вместе выполняют какую-то определенную задачу. С помощью функций можно 
многократно вызывать ее блок операторов как единое целое в других частях программы.
   </p>
   <p>
    Функция объявляется следующим образом:
   </p>
   <pre class="brush:go;">func имя_функции (список_параметров) (типы_возвращаемых_значений){
	выполняемые_операторы
}</pre>
   <p>
    Функция определяется с помощью ключевого слова
    <span class="b">
     func
    </span>
    , после которого идет имя функции. Затем в скобках идет список параметров. 
После списка параметров определяются типы возвращаемых из функции значений (если функция возвращает значения). И далее в фигурных скобках идут собственно те операторы, из 
которых состоит функция.
   </p>
   <p>
    Название функции вместе с типами ее параметров и типами возвращаемых значений еще называют
    <span class="b">
     сигнатурой
    </span>
    .
   </p>
   <p>
    По умолчанию каждая программа на языке Go должна содержать как минимум одну функцию - функцию
    <span class="b">
     main
    </span>
    , которая является входной точкой в приложение:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	fmt.Println("Hello Go")
}</pre>
   <p>
    Функция main начинается с ключевого слова func, затем идет название - main. Функция не принимает никаких параметров, поэтому после названия идут 
пустые скобки. Функция main не возвращает никакого результата, поэтому после пустых скобок не указывается тип возвращаемого значения. И тело функции 
в фигурных скобках фактически состоит из вызова другой функции -
    <code>
     fmt.Println()
    </code>
    , которая выводит строку на консоль.
   </p>
   <p>
    Теперь определим еще одну функцию:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {

}

func hello(){
	fmt.Println("Hello World")
}</pre>
   <p>
    В данном случае мы определили функцию hello, которая не принимает никаких параметров, ничего не возвращает и просто выводит на консоль строку. Определить функцию можно 
в том же файле, где расположена функция main. Но если мы запустим эту программу, но на консоли мы ничего не увидим. Потому что программа выполняет только те действия, которые определены внутри 
функции main. Имя она является входной точкой в приложение. И если мы хотим выполнить в программе нашу функцию
    <code>
     hello
    </code>
    , то нам надо вызвать ее в функции main:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	hello()
	hello()
	hello()
}

func hello(){
	fmt.Println("Hello World")
}</pre>
   <p>
    Для вызова функции пишется ее имя, после которого в скобках указываются значения для параметров функции. Но поскольку в данном случае функция hello не имеет параметров, то 
после ее названия пишем просто пустые скобки. И таким образом, при выполнении программы на консоль три раза будет выведена строка "Hello World":
   </p>
   <div class="console">
    <pre class="consoletext">Hello World
Hello World
Hello World</pre>
   </div>
   <p>
    Таким образом, оформление группы операторов в виде функции позволяет не писать каждый раз всю группу операторов, а обращаться к ним по имени функции.
   </p>
   <h3>
    Параметры функции
   </h3>
   <p>
    Через параметры функция получает входные данные. Параметры указываются в скобках после имени функции. Для каждого параметра указывается имя и тип (как для переменной). 
Друг от друга параметров разделяются запятыми. При вызове функции необходимо передать значения для всех ее параметров. Например, мы хотим использовать функцию, которая складывает два любых числа:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	add(4, 5)	// x + y = 9
	add(20, 6)	// x + y = 26
}

func add(x int, y int){
	var z = x + y
	fmt.Println("x + y = ", z)
}</pre>
   <p>
    Функция add имеет два параметра: x и y. Оба параметра представляют тип int, то есть целые числа. В самой функции определяется переменная, которая хранит сумму этих чисел. 
И затем сумма чисел выводится на консоль.
   </p>
   <p>
    В функции main вызывается функция add. Так как функция принимает два параметра, то при вызове ей необходимо передать значения для этих параметров или два аргумента. 
Причем эти значения должны соответствовать параметрам по типу. То есть если параметр представляет тип int, то ему необходимо передать число.
   </p>
   <p>
    Значения передаются по позиции. То есть первое значение получит первый параметр, второе значение - входной параметр и так далее. В итоге мы получим следующий консольный вывод:
   </p>
   <pre class="brush:go;">x + y = 9
x + y = 26</pre>
   <p>
    Если несколько параметров подряд имеют один и тот же тип, то мы можем указать тип только для последнего параметра, а предыдущие параметры также будут представлять этот тип:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	add(1, 2, 3.4, 5.6, 1.2)
}
func add(x, y int, a, b, c float32){
	var z = x + y
	var d = a + b + c
	fmt.Println("x + y = ", z)
	fmt.Println("a + b + c = ", d)
}</pre>
   <p>
    В качестве аргументов при вызове функции можно передавать и значения переменных, результаты операций или других функций, но при этом следует учитывать, что аргументы в функцию 
всегда передаются по значению:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	var a = 8
	fmt.Println("a before: ", a)
	increment(a)
	fmt.Println("a after: ", a)
}
func increment(x int){

	fmt.Println("x before: ", x)
	x = x + 20
	fmt.Println("x after: ", x)
}</pre>
   <p>
    Консольный вывод:
   </p>
   <div class="console">
    <pre class="consoletext">a before: 8
x before: 8
x after: 28
a after: 8</pre>
   </div>
   <p>
    В данном случае в качестве аргумента в функцию increment передается значение переменной a. Параметр x получает это значение, и оно увеличивается на 20. 
Однако несмотря на то, что значение параметра x увеличилось, значение переменной a никак не изменилось. Потому что при вызове функции передается копия значения переменной.
   </p>
   <h3>
    Неопределенное количество параметров
   </h3>
   <p>
    В Go функция может принимать неопределенное количество параметров одного типа. Например, нам надо получить сумму чисел, но мы точно не значем, сколько 
чисел будут переданы в функцию:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	add(1, 2, 3)		// sum = 6
	add(1, 2, 3, 4)		// sum = 10
	add(5, 6, 7, 2, 3)	// sum = 23
}

func add(numbers ...int){
	var sum = 0
	for _, number := range numbers{
		sum += number
	}
	fmt.Println("sum = ", sum)
}</pre>
   <p>
    Для определения параметра, который представляет неопределенное количество значений, перед типом этих значений ставится многоточие:
    <code>
     numbers ...int
    </code>
    . То есть через подобный параметр мы получаем несколько значений типа int.
   </p>
   <p>
    При вызове мы можем передать в функцию add разное количество чисел:
   </p>
   <pre class="brush:go;">add(1, 2, 3)		// sum = 6
add(1, 2, 3, 4)		// sum = 10
add(5, 6, 7, 2, 3)	// sum = 23</pre>
   <p>
    От этого случае следует отличать передачу среза в качестве параметра:
   </p>
   <pre class="brush:go;">add([]int{1, 2, 3})
add([]int{1, 2, 3, 4})
add([]int{5, 6, 7, 2, 3})</pre>
   <p>
    В данном случае мы получим ошибку, так как передача среза не эквивалентна передаче неопределенного количества параметров того же типа. 
Если мы хотим передать срез, то надо указать после аргумента-массива многоточие:
   </p>
   <pre class="brush:go;">add([]int{1, 2, 3}...)

add([]int{1, 2, 3, 4}...)

var nums = []int{5, 6, 7, 2, 3}
add(nums...)</pre>
  </div>
  <div class="item center menC">
   <h2>
    Возвращение результата из функции
   </h2>
   <div class="date">
    Последнее обновление: 20.12.2017
   </div>
   <p>
    Функции могут возвращать результат. Для этого нужно после списка параметров функции указать тип возвращаемого результата. А в теле функции использовать оператор
    <span class="b">
     return
    </span>
    , после которого указывается возвращаемое значение:
   </p>
   <pre class="brush:go;">func имя_функции (список_параметров) тип_возвращаемого_значения {
	выполняемые_операторы
	return возвращаемое_значение
}</pre>
   <p>
    Например, мы хотим возвратить из функции сумму двух чисел:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	var a = add(4, 5)	// 9
	var b = add(20, 6)	// 26
	fmt.Println(a)
	fmt.Println(b)
}

func add(x, y int) int {
	return x + y
}</pre>
   <p>
    Функция add возвращает значение типа int, поэтому данный тип указан после списка параметров. В самой функции после оператора return указывается возврашаемое значение. 
При этом данное значение может быть значением переменной, литералом, либо же, как в данном случае, результатом операции или вызова функции. То есть выражение
    <code>
     x + y
    </code>
    определяет возвращаемое значение.
   </p>
   <p>
    Поскольку функция возвращает значение, то при вызове функции мы можем получить это значение и передать его переменной:
   </p>
   <pre class="brush:go;">var a = add(4, 5)	// 9
var b = add(20, 6)	// 26</pre>
   <h3>
    Именованные возвращаемые результаты
   </h3>
   <p>
    Возвращаемый результат может быть именован:
   </p>
   <pre class="brush:go;">func add(x, y int) (z int) {
	z = x + y
	return
}</pre>
   <p>
    В скобках после списка параметров фактически определяется переменная, значение которой будет возвращаться. В конце функции ставится оператор return, 
но теперь необязательно после этого оператора ставить возвращаемое значение. Фактически мы также могли бы написать:
   </p>
   <pre class="brush:go;">func add(x, y int) int {
	var z int = x + y
	return z
}</pre>
   <h3>
    Возвращение нескольких значений
   </h3>
   <p>
    В Go функция может возвращать сразу несколько значений. В этом случае после списка параметров указывается в скобках список типов возвращаемых значений. А после оператора return 
располагаются через запятую все возвращаемые значения:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	var age, name = add(4, 5, "Tom", "Simpson")
	fmt.Println(age)	// 9
	fmt.Println(name)	// Tom Simpson
}

func add(x, y int, firstName, lastName string) (int , string) {
	var z int = x + y
	var fullName = firstName + " " + lastName
	return z, fullName
}</pre>
   <p>
    Функция add принимает четыре параметра: два числа и две строки. Возвращает число (значение типа int) и строку. Возвращаемые значения указаны после оператора return.
   </p>
   <p>
    Поскольку функция теперь возвращает два значения, то при вызове этой функции мы можем присвоить ее результат двум переменным:
   </p>
   <pre class="brush:go;">var age, name = add(4, 5, "Tom", "Simpson")</pre>
   <p>
    Первое возвращаемое значение передается первой переменной age, а второе значение передается второй переменной name.
   </p>
   <p>
    Альтернативный способ передачи переменным результатов функции:
   </p>
   <pre class="brush:go;">age, name := add(4, 5, "Tom", "Simpson")</pre>
   <p>
    И также в даном случае можно было бы использовать именованные результаты:
   </p>
   <pre class="brush:go;">func add(x, y int, firstName, lastName string) (z int, fullName string) {
	z = x + y
	fullName = firstName + " " + lastName
	return
}</pre>
  </div>
  <div class="item center menC">
   <h2>
    Тип функции
   </h2>
   <div class="date">
    Последнее обновление: 26.12.2017
   </div>
   <p>
    Каждая функция имеет определенный тип, который складывается из списка типов параметров и списка типов возвращаемых рехультатов. Например, возьмем следующую 
функцию:
   </p>
   <pre class="brush:go;">func add(x int, y int) int{
	return x + y
}</pre>
   Эта функция представляет тип
   <span class="b">
    func(int, int) int
   </span>
   . Этому же типу будет соответствовать следующая функция:
   <pre class="brush:go;">func multiply(x int, y int) int{
	return x * y
}</pre>
   <p>
    Хотя эта функция называется иначе, выполняет другие действия, но по типу параметров и по типу возвращаемого результата она соответствует выше указанному типу функции.
   </p>
   <p>
    Возьмем еще одну функцию:
   </p>
   <pre class="brush:go;">func display(message string){
	fmt.Println(message)
}</pre>
   <p>
    Эта функция имеет тип
    <span class="b">
     func(string)
    </span>
    . То есть опять же вначале идет слово func, а затем в скобках типы параметров. Так как функция не возвращает никакого результата, 
то соответственно возвращаемый тип не указывается.
   </p>
   <p>
    Но какое значение имеет тип функции? Это значит, что мы можем определять переменные или параметры функций, которые будут представлять определенный тип функциии. То есть фактически переменная может быть функцией. Например:
   </p>
   <pre class="brush:go;">package main

import "fmt"

func add(x int, y int) int{
	return x + y
}

func main() {
	
	var f func(int, int) int = add
	fmt.Println(f(3, 4))
	
	var x = f(4, 5)		// 9
	fmt.Println(x)
}</pre>
   <p>
    Здесь переменная f имеет тип
    <code>
     func(int, int) int
    </code>
    , то есть представляет любую функцию, которая принимает два параметра типа int и 
возвращает значение типа int. Поэтому мы можем присвоить этой переменной функцию add, которая соответствует данному типу:
   </p>
   <pre class="brush:go;">var f func(int, int) int = add</pre>
   <p>
    После этого мы можем вызывать присвоенную функцию через переменную, передавая нужные значения для ее параметров:
   </p>
   <pre class="brush:go;">var x = f(4, 5)	// 9</pre>
   <p>
    При этом переменная может изменять функцию, на которую она указывает, но при этому функция обязательно должна соответствовать ее типу:
   </p>
   <pre class="brush:go;">package main

import "fmt"

func add(x int, y int) int{ return x + y}
func multiply(x int, y int) int{ return x * y}

func display(message string){
	fmt.Println(message)
}

func main() {
	
	f := add		//или так var f func(int, int) int = add
	fmt.Println(f(3, 4))		// 7
	
	f = multiply	// теперь переменная f указывает на функцию multiply
	fmt.Println(f(3, 4))		// 12
	
	// f = display		// ошибка, так как функция display имеет тип func(string)
	
	var f1 func(string) = display	// норм 
	f1("hello")
}</pre>
   <h3>
    Функции как параметры других функций
   </h3>
   <p>
    Также функция может передаваться в качестве параметра в другую функцию. Например:
   </p>
   <pre class="brush:go;">package main

import "fmt"

func add(x int, y int) int {
	
	return x + y
}
func multiply(x int, y int) int {
	
	return x * y
}
func action(n1 int, n2 int, operation func(int, int) int){

	result := operation(n1, n2)
	fmt.Println(result)
}
func main() {
	
	action(10, 25, add)		// 35
	action(5, 6, multiply)	// 30
}</pre>
   <p>
    Здесь функция
    <code>
     action
    </code>
    принимает три параметра. Первые два параметра - числа, а третий параметр - функция, которая соответствует типу:
    <code>
     func(int , int) int
    </code>
    . То есть третий параметр представляет некоторое действие и может быть представлен любой функцией, которая принимает два значения типа int и возвращает также 
значение типа int. Для примера здесь как раз определены две подобных функции, которые соответствуют данному типу: add и multiply. Через имя параметра operation 
мы сможем вызывать данную функцию.
   </p>
   <p>
    Или еще один пример:
   </p>
   <pre class="brush:go;">package main

import "fmt"

func isEven(n int) bool{
	return n % 2 == 0
}
func isPositive(n int) bool{
	return n &gt; 0
}

func sum(numbers []int, criteria func(int) bool) int{

	result := 0
	for _, val := range numbers{
		if(criteria(val)){
			result += val
		}
	}
	return result
}
func main() {
	
	slice := []int{-2, 4, 3, -1, 7, -4, 23}
	
	sumOfEvens := sum(slice, isEven)	// сумма четных чисел
	fmt.Println(sumOfEvens)				// -2
	
	sumOfPositives := sum(slice, isPositive)	// сумма положительных чисел
	fmt.Println(sumOfPositives)					// 37
}</pre>
   <p>
    Здесь функция sum вычисляет сумму элементов среза. Но н всех элементов, а только тех, которые соответствуют условию. Условие передается в виде функции в качестве второго параметра. 
Условие должно соответствовать функции типа
    <code>
     func(int) bool
    </code>
    . То есть функция должна принимать в качестве параметра значение типа int и возвращать значение типа bool, которое указывает, 
соответствовует ли переданное число условию.
   </p>
   <p>
    Для примера здесь также определены две вспомогательные функции: isEven (возвращает true, если число четное) и isPositive (возвращает true, если число 
положительное). Эти функции соответствуют типу
    <code>
     func(int) bool
    </code>
    , поэтому их можно использовать в качестве условия.
   </p>
   <h3>
    Функция как результат другой функции
   </h3>
   <p>
    Функция также может возвращаться из другой функции в качестве результата:
   </p>
   <pre class="brush:go;">package main

import "fmt"

func add(x int, y int) int{ return x + y}
func subtract(x int, y int) int{ return x - y}
func multiply(x int, y int) int{ return x * y}

func selectFn(n int) (func(int, int) int){
	if n==1 {
		return add
	}else if n==2{
		return subtract
	}else{
		return multiply
	}
}

func main() {
	
	f := selectFn(1)
	fmt.Println(f(3, 4))		// 7
	
	f = selectFn(3)
	fmt.Println(f(3, 4))		// 12
}</pre>
   <p>
    Здесь в зависимости от значения параметра функция selectFn возвращает одну из трех функций: add, subtract или multiply.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Анонимные функции
   </h2>
   <div class="date">
    Последнее обновление: 26.12.2017
   </div>
   <p>
    Анонимные функции - это функции, которым не назначено имя. Они отличаются от обычных функций также тем, что они могут определяться внутри других функций и также могут 
иметь доступ к контексту выполнения.
   </p>
   <p>
    Анонимные функции позволяют нам определить некоторое действие непосредственно там, где оно применяется. Например, нам надо выполнить сложение двух чисел, но больше нигде 
это действие в программе не нужно:
   </p>
   <pre class="brush:go;">package main

import "fmt"

func main() {
	
	f := func(x, y int) int{ return x + y}
	fmt.Println(f(3, 4))		// 7
	fmt.Println(f(6, 7))		// 13
}</pre>
   <p>
    Фактически переменная f определена как:
   </p>
   <pre class="brush:go;">var f func(int, int) int = func(x, y int) int{ return x + y}</pre>
   <p>
    То есть переменной f можно присвоить любую функцию, которая соответствует типу
    <code>
     func(int, int) int
    </code>
    .
   </p>
   <h3>
    Анонимная функция как аргумент функции
   </h3>
   <p>
    Очень удобно использовать анонимные функции в качестве аргументов других функций:
   </p>
   <pre class="brush:go;">package main

import "fmt"

func action(n1 int, n2 int, operation func(int, int) int){

	result := operation(n1, n2)
	fmt.Println(result)
}
func main() {
	
	action(10, 25, func (x int, y int) int { return x + y })	// 35
	action(5, 6, func (x int, y int) int { return x * y })		// 30
}</pre>
   <h3>
    Анонимная функция как результат функции
   </h3>
   <p>
    Анонимная функция может быть результатом друой функции:
   </p>
   <pre class="brush:go;">package main

import "fmt"

func selectFn(n int) (func(int, int) int){
	if n==1 {
		return func(x int, y int) int{ return x + y}
	}else if n==2{
		return func(x int, y int) int{ return x - y}
	}else{
		return func(x int, y int) int{ return x * y}
	}
}

func main() {
	
	f := selectFn(1)
	fmt.Println(f(2, 3))		// 5
	fmt.Println(f(4, 5))		// 9
	fmt.Println(f(7, 6))		// 13
}</pre>
   <h3>
    Доступ к окружению
   </h3>
   <p>
    Преимуществом анонимных функций является то, что они имеют доступ к окружению, в котором они определяются. Например:
   </p>
   <pre class="brush:go;">package main

import "fmt"

func square() func() int { 
	var x int = 2
	return func() int { 
		x++
		return x * x
	}
}

func main() {
	
	f := square()
	fmt.Println(f())		// 9
	fmt.Println(f())		// 16
	fmt.Println(f())		// 25
}</pre>
   <p>
    Здесь функция square определяет локальную переменную x и возвращает анонимную функцию. Анонимная функция увеливичает значение переменной x и возвращает ее квадрат.
   </p>
   <p>
    Таким образом, мы можем зафисировать у внешней функции square состояние в виде переменной x, которое будет изменяться в анонимной функции.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Рекурсивные функции
   </h2>
   <div class="date">
    Последнее обновление: 26.12.2017
   </div>
   <p>
    Рекурсивная функция представляет такую функцию, которая вызывает саму себя. Рекурсивные функции представляют мощный инструмент для обработки рекурсивных структур данных, например, 
различных деревьев.
   </p>
   <p>
    Например, определим функцию вычисления факториала числа, которая получает результат рекурсивным способом:
   </p>
   <pre class="brush:go;">package main

import "fmt"

func factorial(n uint) uint{

	if n == 0{
		return 1
	}
	return n * factorial(n - 1)
}
func main() {
	
	fmt.Println(factorial(4))	// 24
	fmt.Println(factorial(5))	// 120
	fmt.Println(factorial(6))	// 720
}</pre>
   <p>
    Здесь функция factorial получает некоторое положительное число, для которого надо вычислить факториал. Полученный результат возвращается из функции. 
Вначале идет условие, что если число равно 0, то функция возвращает 1. Иначе функция возвращает произведение числа n на результат этой же функции для числа n-1.
   </p>
   <p>
    При создании рекурсивной функции в ней обязательно должен быть некоторый базовый вариант, который использует оператор return и помещается в 
начале функции. В случае с факториалом это
    <code>
     if x == 0 {return 1}
    </code>
    .
   </p>
   <p>
    И, кроме того, все рекурсивные вызовы должны обращаться к подфункциям, которые в конце концов сходятся к базовому варианту. Так, при передаче в 
функцию положительного числа при дальнейших рекурсивных вызовах подфункций в них будет передаваться каждый раз число, меньшее на единицу. И в 
конце концов мы дойдем до ситуации, когда число будет равно 0, и будет использован базовый вариант.
   </p>
   <p>
    Например, вызов
    <code>
     factorial(4)
    </code>
    фактически можно расписать следующим образом:
   </p>
   <ul>
    <li>
     <p>
      factorial(4)
     </p>
    </li>
    <li>
     <p>
      4 * factorial(3)
     </p>
    </li>
    <li>
     <p>
      4 * 3 * factorial(2)
     </p>
    </li>
    <li>
     <p>
      4 * 3 * 2 * factorial(1)
     </p>
    </li>
    <li>
     <p>
      4 * 3 * 2 * 1 * factorial(0)
     </p>
    </li>
    <li>
     <p>
      4 * 3 * 2 * 1 * 1
     </p>
    </li>
   </ul>
   <p>
    Другим распространенным показательным примером рекурсивной функции служит функция, вычисляющая числа Фибоначчи. n-й член последовательности 
Фибоначчи определяется по формуле: f(n)=f(n-1) + f(n-2), причем f(0)=0, а f(1)=1.
   </p>
   <pre class="brush:go;">package main

import "fmt"

func fibbonachi(n uint) uint{
	
	if n == 0 {
		return 0
	}
	if n == 1 {
		return 1
	}
	return fibbonachi(n - 1) + fibbonachi(n - 2)
}
func main() {
	
	fmt.Println(fibbonachi(4))	// 3
	fmt.Println(fibbonachi(5))	// 5
	fmt.Println(fibbonachi(6))	// 8
}</pre>
  </div>
  <div class="item center menC">
   <h2>
    defer и panic
   </h2>
   <div class="date">
    Последнее обновление: 21.01.2017
   </div>
   <h3>
    defer
   </h3>
   <p>
    Оператор
    <span class="b">
     defer
    </span>
    позволяет выполнить определенную функцию в конце программы, при этом не важно, где в 
реальности вызывается эта функция. Например:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	defer finish()
	fmt.Println("Program has been started")
	fmt.Println("Program is working")
}

func finish(){
	fmt.Println("Program has been finished")
}</pre>
   <p>
    Здесь функция finish вызывается с оператором defer, поэтому данная функция в реальности будет вызываться в самом конце выполнения программы, несмотря на то, что 
ее вызов определен в начале функции main. В частности, мы получим следующий консольный вывод:
   </p>
   <div class="console">
    <pre class="consoletext">Program has been started
Program is working
Program has been finished</pre>
   </div>
   <p>
    Если несколько функций вызываются с оператором defer, то те функции, которые вызываются раньше, будут выполняться позже всех. Например:
   </p>
   <pre class="brush:go;">package main
import  "fmt"

func main() {
     
	defer finish()
	defer fmt.Println("Program has been started")
	fmt.Println("Program is working")
}

func finish(){
	fmt.Println("Program has been finished")
}</pre>
   <p>
    Консольный вывод:
   </p>
   <div class="console">
    <pre class="consoletext">Program is working
Program has been started
Program has been finished</pre>
   </div>
   <h3>
    panic
   </h3>
   <p>
    Оператор
    <span class="b">
     panic
    </span>
    позволяет сгенерировать ошибку и выйти из программы:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	fmt.Println(divide(15, 5))
	fmt.Println(divide(4, 0))
	fmt.Println("Program has been finished")
}
func divide(x, y float64) float64{
	if y == 0{ 
		panic("Division by zero!")
	}
	return x / y
}</pre>
   <p>
    Оператору panic мы можем передать любое сообщение, которое будет выводиться на консоль. Например, в данном случае в функции divide, если второй параметр равен 0, то 
осуществляется вызов
    <code>
     panic("Division by zero!")
    </code>
    .
   </p>
   <p>
    В функции main в вызове
    <code>
     fmt.Println(divide(4, 0))
    </code>
    будет выполняться оператор panic, поскольку второй параметр функции divide равен 0. И в этом случае все последующие операции, 
которые идут после этого вызова, например, в данном случае это вызов
    <code>
     fmt.Println("Program has been finished")
    </code>
    , не будут выполняться. В этом случае 
мы получим следующий консольный вывод:
   </p>
   <div class="console">
    <pre class="consoletext">3
panic: Division by zero!</pre>
   </div>
   <p>
    И в конце вывода будет идти диагностическая информация о том, где возникла ошибка.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Срезы
   </h2>
   <div class="date">
    Последнее обновление: 21.12.2017
   </div>
   <p>
    Срезы (slice) представляют последовательность элементов одного типа переменной длины. В отличие от массивов длина в срезах не иксирована и динамически может меняться, 
то есть можно добавлять новые элементы или удалять уже существующие.
   </p>
   <p>
    Срез определяется также, как и массив, за тем исключением, что у него не указывается длина:
   </p>
   <pre class="brush:go;">var users []string</pre>
   <p>
    Также срез можно инициализировать значениями:
   </p>
   <pre class="brush:go;">var users = []string{"Tom", "Alice", "Kate"}
// или так
users2 := []string{"Tom", "Alice", "Kate"}</pre>
   <p>
    К элементам среза обращение происходит также, как и к элементам массива - по индексу и также мы можем перебирать все элементы с помощью цикла 
for:
   </p>
   <pre class="brush:go;">var users []string = []string{"Tom", "Alice", "Kate"}
fmt.Println(users[2])	// Kate
users[2] = "Katherine"

for _, value := range users{
	fmt.Println(value)</pre>
   <p>
    С помощью функции
    <span class="b">
     make()
    </span>
    можно создать срез из нескольких элементов, которые будут иметь значения по умолчанию:
   </p>
   <pre class="brush:go;">var users []string = make([]string, 3)
users[0] = "Tom"
users[1] = "Alice"
users[2] = "Bob"</pre>
   <h3>
    Добавление в срез
   </h3>
   <p>
    Для добавления в срез применяется встроенная функция
    <span class="b">
     append(slice, value)
    </span>
    . Первый параметр функции - срез, в который надо добавить, а второй параметр - 
значение, которое нужно добавить. Результатом функции является увеличенный срез.
   </p>
   <pre class="brush:go;">users := []string{"Tom", "Alice", "Kate"}
users = append(users, "Bob")
	
for _, value := range users{
	fmt.Println(value)
}</pre>
   <h3>
    Оператор среза
   </h3>
   <p>
    Оператор среза s[i:j] создает из последовательности s новый срез, который содержит элементы последовательности s с i по j-1. 
При этом должно соблюдаться условие
    <code>
     0 &lt;= i &lt;= j &lt;= cap(s)
    </code>
    . В качестве исходной последовательности, из которой берутся элементы, 
может использоваться массив, указатель на массив или другой срез. В итоге в полученном срезе будет j-i элементов.
   </p>
   <p>
    Если значение i не указано, то применяется по умолчанию значение 0. Если значение j не указано, то вместо него используется длина исходной последовательности s.
   </p>
   <pre class="brush:go;">// исходный массив
initialUsers := [8]string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"}
users1 := initialUsers[2:6]		// с 3-го по 6-й 
users2 := initialUsers[:4]		// с 1-го по 4-й
users3 := initialUsers[3:]		// с 4-го до конца
	
fmt.Println(users1)		// ["Kate", "Sam", "Tom", "Paul"]
fmt.Println(users2)		// ["Bob", "Alice", "Kate", "Sam"]
fmt.Println(users3)		// ["Sam", "Tom", "Paul", "Mike", "Robert"]</pre>
   <h3>
    Удаление элемента
   </h3>
   <p>
    Что делать, если необходимо удалить какой-то определенный элемент? В этом случае мы можем комбинировать функцию append и оператор среза:
   </p>
   <pre class="brush:go;">users := []string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"}
//удаляем 4-й элемент
var n = 3
users = append(users[:n], users[n+1:]...)	
fmt.Println(users)		//["Bob", "Alice", "Kate", "Tom", "Paul", "Mike", "Robert"]</pre>
  </div>
  <div class="item center menC">
   <h2>
    Отображения
   </h2>
   <div class="date">
    Последнее обновление: 21.01.2017
   </div>
   <p>
    Отображение или map представляет ссылку на хеш-таблицу - структуру данных, где каждый элемент представляет пару "ключ-значение". При этом каждый элемент имеет уникальный ключ, по которому можно получить 
значение элемента. Отображение определяется как объект типа
    <span class="b">
     map[K]V
    </span>
    , где К представляет тип ключа, а V - тип значения. 
Причем тип ключа K должен поддерживать операцию сравнения ==, чтобы оображение могло сопоставить значение с одним из ключей и хеш-таблицы.
   </p>
   <p>
    Например, определение отображения, которое в качестве ключей имеет тип string, а в качестве значений - тип int:
   </p>
   <pre class="brush:go;">var people map[string]int	// Ключи представляют тип string, значения - тип int</pre>
   <p>
    Установка значений отображения:
   </p>
   <pre class="brush:go;">var people = map[string]int{ 
	"Tom": 1,
	"Bob": 2,
	"Sam": 4,
	"Alice": 8,
}
fmt.Println(people)		// map[Tom:1 Bob:2 Sam:4 Alice:8]</pre>
   <p>
    Как и в массиве или в срезе элементы помещаютя в фигурные скобки. Каждый элемент представляет пару ключ -значение. Вначале идет ключ и через двоеточие значение. Определение элемента завершается запятой.
   </p>
   <p>
    Для обращения к элементам нужно применять ключи:
   </p>
   <pre class="brush:go;">var people = map[string]int{ 
	"Tom": 1,
	"Bob": 2,
	"Sam": 4,
	"Alice": 8,
}
fmt.Println(people["Alice"])		// 8
fmt.Println(people["Bob"])			// 2
people["Bob"] = 32
fmt.Println(people["Bob"])			// 32</pre>
   <p>
    Для проверки наличия элемента по определенному ключу можно применять выражение if:
   </p>
   <pre class="brush:go;">var people = map[string]int{ 
	"Tom": 1,
	"Bob": 2,
	"Sam": 4,
	"Alice": 8,
}
if val, ok := people["Tom"]; ok{
	fmt.Println(val)
}</pre>
   <p>
    Если значение по заданному ключу имеется в отображении, то переменная ok будет равна true, а переменная val будет хранить полученное значение. 
Если переменная ok равна false, то значения по ключу в отображении нет.
   </p>
   <p>
    Для перебора элементов применяется цикл for:
   </p>
   <pre class="brush:go;">var people = map[string]int{ 
	"Tom": 1,
	"Bob": 2,
	"Sam": 4,
	"Alice": 8,
}
for key, value := range people{
	fmt.Println(key, value)
}</pre>
   <p>
    Консольный вывод программы:
   </p>
   <div class="console">
    <pre class="consoletext">Tom 1
Bob 2
Sam 4
Alice 8</pre>
   </div>
   <p>
    Функция
    <span class="b">
     make
    </span>
    представляет альтернативный вариант создания отображения. Она создает пустую хеш-таблицу:
   </p>
   <pre class="brush:go;">people := make(map[string]int)</pre>
   <h3>
    Добавление и удаление элементов
   </h3>
   <p>
    Для добавления элементов достаточно просто выполнить установку значения по новому ключу и элемент с этим ключом будет добавлен в коллекцию:
   </p>
   <pre class="brush:go;">var people = map[string]int{ "Tom": 1, "Bob": 2}
people["Kate"] = 128
fmt.Println(people)		// map[Tom:1  Bob:2  Kate:128]</pre>
   <p>
    Для удаления применяется встроенная функция
    <span class="b">
     delete(map, key)
    </span>
    , первым параметром которой является отображение, а вторым - ключ, по которому надо 
удалить элемент.
   </p>
   <pre class="brush:go;">var people = map[string]int{ "Tom": 1, "Bob": 2, "Sam": 8}
delete(people, "Bob")
fmt.Println(people)		// map[Tom:1  Sam:8]</pre>
  </div>
  <div class="item center menC">
   <h1>
    Указатели
   </h1>
   <h2>
    Что такое указатели
   </h2>
   <div class="date">
    Последнее обновление: 24.12.2017
   </div>
   <p>
    Указатели представляют собой объекты, значением которых служат адреса других объектов (например, переменных).
   </p>
   <p>
    Указатель определяется как обычная переменная, только перед типом данных ставится символ звездочки *. Например, определение указателя на объект типа int:
   </p>
   <pre class="brush:go;">var p *int</pre>
   <p>
    Этому указателю можно присвоить адрес переменной типа int. Для получения адреса применяется операция
    <span class="b">
     &amp;
    </span>
    , после которой указывается 
имя переменной (
    <code>
     &amp;x
    </code>
    ).
   </p>
   <pre class="brush:go;">package main

import "fmt"

func main() {
	
	var x int = 4		// определяем переменную
	var p *int 			// определяем указатель	
	p = &amp;x				// указатель получает адрес переменной
	fmt.Println(p)		// значение самого указателя - адрес переменной x
}</pre>
   <p>
    Здесь указатель p хранит адрес переменной x.  Что важно, переменная x имеет тип int, и указатель p указывает именно на объект типа int. То есть должно быть соответствие по типу. 
И если мы попробуем вывести адрес переменной на консоль, то увидим, что он представляет шестнадцатеричное значение:
   </p>
   <div class="console">
    <pre class="consoletext">0xc0420120a0</pre>
   </div>
   <p>
    В каждом отдельном случае адрес может отличаться, но к примеру, в моем случае машинный адрес переменной x - 0xc0420120a0. То есть в памяти 
компьютера есть адрес 0xc0420120a0, по которому располагается переменная x.
   </p>
   <p>
    По адресу, который хранит указатель, мы получить значение переменной x. Для этого применяется операция
    <span class="b">
     *
    </span>
    или операция 
разыменования. Результатом этой операции является значение переменной, на которую указывает указатель. Применим данную операцию и получим значение переменной x:
   </p>
   <pre class="brush:go;">package main

import "fmt"

func main() {
	
	var x int = 4
	var p *int  = &amp;x				// указатель получает адрес переменной
	fmt.Println("Address:", p)		// значение указателя - адрес переменной x
	fmt.Println("Value:", *p)		// значение переменной x
}</pre>
   <p>
    Консольный вывод:
   </p>
   <div class="console">
    <pre class="consoletext">Address: 0xc0420c058
Value: 4</pre>
   </div>
   <p>
    И также используя указатель, мы можем менять значение по адресу, который хранится в указателе:
   </p>
   <pre class="brush:go;">var x int = 4
var p *int = &amp;x
*p = 25
fmt.Println(x)		// 25</pre>
   <p>
    Для определения указателей можно использовать также сокращенную форму:
   </p>
   <pre class="brush:go;">f := 2.3
pf := &amp;f
	
fmt.Println("Address:", pf)
fmt.Println("Value:", *pf)</pre>
   <h3>
    Пустой указатель
   </h3>
   <p>
    Если указателю не присвоен адрес какого-либо объекта, то такой указатель по умолчанию имеет значение
    <span class="b">
     nil
    </span>
    (по сути отстутствие значения). 
Если мы попробуем получить значение по такому пустому указателю, то мы столкнемся с ошибкой:
   </p>
   <pre class="brush:go;">var pf *float64
fmt.Println("Value:", *pf)	// ! ошибка, указатель не указывает на какой-либо объект</pre>
   <p>
    Поэтому при работе с указателями иногда бывает целесообразано проверять на значение nil:
   </p>
   <pre class="brush:go;">var pf *float64
if pf != nil{
	fmt.Println("Value:", *pf)
}</pre>
   <h3>
    Функция new
   </h3>
   <p>
    Переменная представляет именованный объект в памяти. Язык Go также позволяет создавать безымянные объекты - они также размещаются в памяти, 
но не имеют имени как переменные. Для этого применяется функция
    <span class="b">
     new(type)
    </span>
    . В эту функцию передается тип, объект которого надо создать. 
Функция возвращает указатель на созданный объект:
   </p>
   <pre class="brush:go;">package main

import "fmt"

func main() {
	
	p := new(int) 
	fmt.Println("Value:", *p)		// Value: 0 - значение по умолчанию
	*p = 8							// изменяем значение
	fmt.Println("Value:", *p)		// Value: 8
}</pre>
   <p>
    В данном случае указатель p будет иметь тип
    <code>
     *int
    </code>
    , поскольку он указывает на объект типа int. Создаваемый объект имеет значение по умолчанию (для типа int 
это число 0).
   </p>
   <p>
    Объект, созданный с помощью функции new, ничем не отличается от обычной переменной. Единственное что, чтобы обратиться к этому объекту - получить или 
изменить его адрес, необходимо использовать указатель.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Указатели и функции
   </h2>
   <div class="date">
    Последнее обновление: 24.12.2017
   </div>
   <h3>
    Указатели как параметры функции
   </h3>
   <p>
    По умолчанию все параметры передаются в функцию по значению. Например:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func changeValue(x int){
	x = x * x
}
func main() {
	
	d := 5
	fmt.Println("d before:", d)		// 5
	changeValue(d)					// изменяем значение
	fmt.Println("d after:", d)		// 5 - значение не изменилось
}</pre>
   <p>
    Функция changeValue изменяет значение параметра, возводя его в квадрат. Но после вызова этой функции мы видим, что значение переменной d, которая передается в changeValue, не изменилось. 
Ведь функция получает копию данной переменной и работает с ней независимо от оригинальной переменной d. Поэтому d никак не изменяется.
   </p>
   <p>
    Однако что, если нам все таки надо менять значение передаваемой переменной? И в этом случае мы можем использовать указатели:
   </p>
   <pre class="brush:go;">package main

import "fmt"

func changeValue(x *int){
	*x = (*x) * (*x)
}
func main() {
	
	d := 5
	fmt.Println("d before:", d)		// 5
	changeValue(&amp;d)					// изменяем значение
	fmt.Println("d after:", d)		// 25 - значение изменилось!
}</pre>
   <p>
    Теперь функция changeValue принимает в качестве параметра указатель на объект типа int. При вызове функции changeValue в нее передается адрес переменной 
d (
    <code>
     changeValue(&amp;d)
    </code>
    ). И после ее выполнения мы видим, что значение переменной d изменилось.
   </p>
   <h3>
    Указатель как результат функции
   </h3>
   <p>
    Функция может возвращать указатель:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func createPointer(x int) *int{
	p := new(int)
	*p = x
	return p
}

func main() {
	
	p1 := createPointer(7)
	fmt.Println("p1:", *p1)		// p1: 7
	p2 := createPointer(10)
	fmt.Println("p2:", *p2)		// p2: 10
	p3 := createPointer(28)
	fmt.Println("p3:", *p3)		// p3: 28
}</pre>
   <p>
    В данном случае функция createPointer возвращает указатель на объект int.
   </p>
  </div>
  <div class="item center menC">
   <h1>
    Производные типы
   </h1>
   <h2>
    Именованные типы и псевдонимы
   </h2>
   <div class="date">
    Последнее обновление: 18.02.2024
   </div>
   <p>
    Оператор
    <span class="b">
     type
    </span>
    позволяет определять именнованный тип на основе другого. Например:
   </p>
   <pre class="brush:go;">type mile uint</pre>
   <p>
    В данном случае определяется именованный тип mile, который основывается на типе uint. По сути mile представляет тип uint и работа с ним будет производиться также, как и с типом uint. 
Однако в то же время фактически это новый тип.
   </p>
   <p>
    Мы можем определять переменные данного типа, работать с ними как с объектами базового типа uint:
   </p>
   <pre class="brush:go;">package main
import "fmt"

type mile uint

func main() {
	
	var distance mile = 5
	fmt.Println(distance)
	distance += 5
	fmt.Println(distance)
}</pre>
   <p>
    Но может возникнуть вопрос, а зачем это нужно, зачем определять именнованный тип, если он все равно ведет себя как тип
    <span class="b">
     uint
    </span>
    ? Рассмотрим следующую ситуацию:
   </p>
   <pre class="brush:go;">package main
import "fmt"

type mile uint
type kilometer uint

func distanceToEnemy (distance mile){
	
	fmt.Println("расстояние для противника:")
	fmt.Println(distance, "миль")
}

func main() {
	
	var distance mile = 5
	distanceToEnemy(distance)

	
    // var distance1 uint = 5
    // distanceToEnemy(distance1)   // !Ошибка

	// var distance2 kilometer = 5
	// distanceToEnemy(distance2)	// ! ошибка
}</pre>
   <p>
    Здесь определены два именнованных типа: mile и kilometer, которые по сути представляют тип uint и которые предназначены для выражения расстояния в милях 
и километрах соответственно. И также определена функция
    <code>
     distanceToEnemy()
    </code>
    , которая отображает расстояние в милях до условного противника. 
В качестве параметра принимает значение mile - именно значение типа mile, а не типа uint. Это позволит нам уменьшить вероятность передачи некорректных данных. То есть 
передаваемые данные должны быть явным образом определены в программе как значение типа mile, а не типа uint или типа kilometer. Два именнованных типа считаются разными, даже 
если они основаны на некотором общем типе (как uint в данном случае).
   </p>
   <p>
    Также именнованные типы позволяют придать типу некоторый дополнительный смысл. Так, использование в коде типа "kilometer" или "mile" позволит указать на предназначение переменной или параметра и 
будет более описательным, чем просто тип
    <code>
     uint
    </code>
    .
   </p>
   <p>
    Еще одна ситуация, где можно применять именнованные типы - это сокращение названия типов в том случае, если они слишком длинные или громоздкие. Например, рассмотрим следующий пример:
   </p>
   <pre class="brush:go;">package main
 
import "fmt"

func action(n1 int, n2 int, op func(int, int) int){
 
    result := op(n1, n2)
    fmt.Println(result)
}

func add(x int, y int) int {
     
    return x + y
}

func main() {
     
	var myOperation func(int, int) int = add
    action(10, 25, myOperation)     // 35
}</pre>
   <p>
    Здесь определена функция action, которая принимает два числа и некоторую другую функцию с типом
    <code>
     func(int, int) int
    </code>
    - то есть функцию, которая принимает два числа и также возвращает число. 
В функции main определяется переменная myOperation, которая как раз представляет функцию типа
    <code>
     func(int, int) int
    </code>
    , получает ссылку на функцию add и 
передается в вызов
    <code>
     action(10, 25, myOperation)
    </code>
   </p>
   <p>
    Теперь определим именнованный тип для типа
    <code>
     func(int, int) int
    </code>
    :
   </p>
   <pre class="brush:go;">package main
 
import "fmt"
 
type BinaryOp func(int, int) int

func action(n1 int, n2 int, op BinaryOp){
 
    result := op(n1, n2)
    fmt.Println(result)
}

func add(x int, y int) int {
     
    return x + y
}

func main() {
     
	var myOperation BinaryOp = add
    action(10, 35, myOperation)     // 45
}</pre>
   <p>
    Теперь тип функции
    <code>
     func(int, int) int
    </code>
    проецируется на именнованный тип BinaryOp, который представляет бинарную операцию над двумя операндами:
   </p>
   <pre class="brush:go;">type BinaryOp func(int, int) int</pre>
   <p>
    Такое название короче оригинального определения типа и в то же время является более описательным (по крайней мере для меня). Соответственно далее его можно использовать для указания типа параметра:
   </p>
   <pre class="brush:go;">func action(n1 int, n2 int, op BinaryOp){ ... }</pre>
   <p>
    или переменной:
   </p>
   <pre class="brush:go;">var myOperation BinaryOp = add</pre>
   <h3>
    Псевдонимы
   </h3>
   <p>
    На именнованные типы похожи псевдонимы. Они также определяются с помощью оператора
    <span class="b">
     type
    </span>
    , только при присвоении типа применяется операция присваивания:
   </p>
   <pre class="brush:go;">type псевдоним = имеющийся_тип</pre>
   <p>
    Однако псевдоним НЕ определяет нового типа и все псевдонимы одного и того же типа считаются идентичными. Например:
   </p>
   <pre class="brush:go;">package main
import "fmt"
 
type mile = uint
type kilometer = uint
 
func distanceToEnemy (distance mile){
     
    fmt.Println("расстояние для противника:")
    fmt.Println(distance, "миль")
}
 
func main() {
     
    var distance mile = 5
    distanceToEnemy(distance)

    var distance1 uint = 5
    distanceToEnemy(distance1)   // норм 

    var distance2 kilometer = 5
    distanceToEnemy(distance2)   // норм
}</pre>
   <p>
    Здесь для типа
    <span class="b">
     uint
    </span>
    определяются два псевдонима - mile и kilometer. И несмотря на то, что параметр функции distanceToEnemy определен как параметр типа mile, 
ему можно передать и значение собственно типа uint, и значение его псевдонима - kilometer.
   </p>
   <p>
    Обычо псевдонимы применяются для сокращения названий других типов или для определения более описательного имени.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Структуры
   </h2>
   <div class="date">
    Последнее обновление: 24.12.2017
   </div>
   <p>
    Структуры представляют тип данных, определяемый разработчиком и служащий для представления каких-либо объектов. Структуры содержат набор полей, 
которые представляют различные атрибуты объекта. Для определения структуры применяются ключевые слова
    <span class="b">
     type
    </span>
    и
    <span class="b">
     struct
    </span>
    :
   </p>
   <pre class="brush:go;">type имя_структуры struct{
	поля_структуры
}</pre>
   <p>
    Каждое поле имеет название и тип данных, как переменная. Например, определим структуру, которая представляет человека:
   </p>
   <pre class="brush:go;">type person struct{
	name string
	age int
}</pre>
   <p>
    Структура называется person. Она имеет два поля: name (имя человека, представляет тип string) и age (возраст человека, представляет тип int).
   </p>
   <h3>
    Создание и инициализация структуры
   </h3>
   <p>
    Структура представляет новый тип данных, и мы можем определить переменную данного типа:
   </p>
   <pre class="brush:go;">var tom person</pre>
   <p>
    С помощью инициализатора можно передать структуре начальные значения:
   </p>
   <pre class="brush:go;">var tom person = person{"Tom", 23}</pre>
   <p>
    Инициализатор представляет набор значений в фигурных скобках. Причем эти значения передаются полям структуры в том порядке, в 
котором поля определены в структуре. Например, в данном случае строка "Tom" передается первому полю - name, а второе значение - 23 
передается второму полю - age.
   </p>
   <p>
    Также мы можем явным образом указать какие значения передаются свойствам:
   </p>
   <pre class="brush:go;">var alice person = person{age: 23, name: "Alice"}</pre>
   <p>
    Также можно использовать сокращенные способы инициализации переменной структуры:
   </p>
   <pre class="brush:go;">var tom = person {name: "Tom", age: 24}
bob := person {name: "Bob", age: 31}</pre>
   <p>
    Можно даже не указывать никаких значений, в этом случае свойства структуры получат значения по умолчанию:
   </p>
   <pre class="brush:go;">undefined := person {}	// name - пустая строка, age - 0</pre>
   <h3>
    Обращение к полям структуры
   </h3>
   <p>
    Для обращения к полям структуры после переменной ставится точка и указывается поле структуры:
   </p>
   <pre class="brush:go;">package main
import "fmt"

type person struct{
	name string
	age int
}

func main() {
	
	var tom = person {name: "Tom", age: 24}
	fmt.Println(tom.name)		// Tom
	fmt.Println(tom.age)		// 24
	
	tom.age = 38	// изменяем значение
	fmt.Println(tom.name, tom.age)		// Tom 38
}</pre>
   <h3>
    Указатели на структуры
   </h3>
   <p>
    Как и в случае с обычными переменнами, можно создавать указатели на структуры.
   </p>
   <pre class="brush:go;">package main
import "fmt"

type person struct{
	name string
	age int
}

func main() {
	
	tom := person {name: "Tom", age: 22}
	var tomPointer *person = &amp;tom
	tomPointer.age = 29
	fmt.Println(tom.age)		// 29
	(*tomPointer).age = 32
	fmt.Println(tom.age)		// 32
}</pre>
   <p>
    Для инициализации указателя на структуру необязательно присваивать ему адрес переменной. Можно присвоить адрес безымянного объекта следующим образом:
   </p>
   <pre class="brush:go;">var tom *person = &amp;person{name:"Tom", age:23}
var bob *person = new(person)</pre>
   <p>
    Для обращения к полям структуры через указатель можно использовать операцию разыменования (
    <code>
     (*tomPointer).age
    </code>
    ), либо напрямую обращаться по указателю 
(
    <code>
     tomPointer.age
    </code>
    ).
   </p>
   <p>
    Также можно определять указатели на отдельные поля структуры:
   </p>
   <pre class="brush:go;">tom := person {name: "Tom", age: 22}
var agePointer *int = &amp;tom.age	// указатель на поле tom.age
*agePointer = 35			// изменяем значение поля
fmt.Println(tom.age)		//  35</pre>
  </div>
  <div class="item center menC">
   <h2>
    Вложенные структуры
   </h2>
   <div class="date">
    Последнее обновление: 24.12.2017
   </div>
   <p>
    Поля одних структур могут представлять другие структуры. Например:
   </p>
   <pre class="brush:go;">package main
import "fmt"

type contact struct{
	email string
	phone string
}

type person struct{
	name string
	age int
	contactInfo contact
}

func main() {
	
	var tom = person {
		name: "Tom", 
		age: 24,
		contactInfo: contact{
			email: "tom@gmail.com",
			phone: "+1234567899",
		},
	}
	tom.contactInfo.email = "supertom@gmail.com"
	
	fmt.Println(tom.contactInfo.email)		// supertom@gmail.com
	fmt.Println(tom.contactInfo.phone)		// +1234567899
}</pre>
   <p>
    В данном случае структура person имеет поле contactInfo, которое представляет другую структуру
    <code>
     contact
    </code>
    .
   </p>
   <p>
    Можно сократить определение поля следующим образом:
   </p>
   <pre class="brush:go;">package main
import "fmt"

type contact struct{
	email string
	phone string
}

type person struct{
	name string
	age int
	contact
}

func main() {
	
	var tom = person {
		name: "Tom", 
		age: 24,
		contact: contact{
			email: "tom@gmail.com",
			phone: "+1234567899",
		},
	}
	tom.email = "supertom@gmail.com"
	
	fmt.Println(tom.email)		// supertom@gmail.com
	fmt.Println(tom.phone)		// +1234567899
}</pre>
   <p>
    Поле contact в структуре person фактические эквивалентно свойству
    <code>
     contact contact
    </code>
    , то есть свойство называется contact и 
представляет тип contact. Это позволяет нам сократить путь к полям вложенной структуры. Например, мы можем написать
    <code>
     tom.email
    </code>
    , а не
    <code>
     tom.contact.email
    </code>
    . Хотя можно использовать и второй вариант.
   </p>
   <h3>
    Хранения ссылки на структуру того же типа
   </h3>
   <p>
    При этом надо учитывать, что структура не может иметь поле, которое представляет тип этой же структуры. Например:
   </p>
   <pre class="brush:go;">type node struct{
	value int
	next node
}</pre>
   <p>
    Подобное определение будет неправильным. Вместо этого поле должно представлять указатель на структуру:
   </p>
   <pre class="brush:go;">package main
import "fmt"

type node struct{
	value int
	next *node
}

// рекурсивный вывод списка
func printNodeValue(n *node){
	
	fmt.Println(n.value)
	if n.next != nil{
		printNodeValue(n.next)
	}
}
func main() {
	
	first := node{value: 4}
	second := node{value: 5}
	third := node{value: 6}
	
	first.next = &amp;second
	second.next = &amp;third
	
	var current *node = &amp;first
	for current != nil{
		fmt.Println(current.value)
		current = current.next
	}
}</pre>
   <p>
    Здесь определена структура node, которая представляет типичный узел односвязного списка. Она хранит значение в поле value и ссылку на следующий 
узел через указатель next.
   </p>
   <p>
    В функции main создаются три связанных структуры, и с помощью цикла for и вспомогательного указателя current выводятся их значения.
   </p>
   <div class="console">
    <pre class="consoletext">4
5
6</pre>
   </div>
  </div>
  <div class="item center menC">
   <h2>
    Методы
   </h2>
   <div class="date">
    Последнее обновление: 26.12.2017
   </div>
   <p>
    Метод представляет функцию, связанную с определенным типом. Методы определяются также как и обычные функции за тем исключением, что в определении 
метода также необходимо указать получателя или receiver. Получатель - это параметр того типа, к которому прикрепляется метод:
   </p>
   <pre class="brush:go;">func (имя_параметра тип_получателя) имя_метода (параметры) (типы_возвращаемых_результатов){
	тело_метода
}</pre>
   <p>
    Допустим, у нас будет определен именованный тип, представляющий срез из строк:
   </p>
   <pre class="brush:go;">type library []string</pre>
   <p>
    Для вывода всех элементов из среза мы можем определить следующий метод:
   </p>
   <pre class="brush:go;">func (l library) print(){

	for _, val := range l{
		fmt.Println(val)
	}
}</pre>
   <p>
    Та часть, которая расположена между ключевым словом
    <code>
     func
    </code>
    и именем метода и представляет определение
    <span class="ii">
     получателя
    </span>
    , 
для которого будет определен этот метод:
    <code>
     (l library)
    </code>
    . Используя параметр получателя (в данном случае l), мы можем обращаться к получателю. 
Например, в нашем случае получатель представляет срез - набор объектов. С помощью цикла for можно пройтись по этому срезу и вывести все его элементы 
на консоль.
   </p>
   <p>
    Поскольку print представляет именно метод, который определен для типа library, а не обычную функцию, то мы можем вызвать этот метод у любого объекта типа library:
   </p>
   <pre class="brush:go;">var lib library = library{ "Book1", "Book2", "Book3" }
lib.print()</pre>
   <p>
    lib является объектом типа library, поэтому для него мы можем вызвать метод print. В данном случае объект lib - это и будет то значение, которое будет 
передаваться в функцию print через параметр
    <code>
     (l library)
    </code>
    .
   </p>
   <h3>
    Методы структур
   </h3>
   <p>
    Подобным образом мы можем определять методы и для структур:
   </p>
   <pre class="brush:go;">package main

import "fmt"

type person struct{
	name string
	age int
}
func (p person) print(){
	fmt.Println("Имя:", p.name)
	fmt.Println("Возраст:", p.age)
}

func (p person) eat(meal string){
	fmt.Println(p.name, "ест", meal)
}

func main() {
	
	var tom = person { name: "Tom", age: 24 }
	tom.print()
	tom.eat("борщ с капустой, но не красный")
}</pre>
   <p>
    Консольный вывод данной программы:
   </p>
   <div class="console">
    <pre class="consoletext">Имя: Tom
Возраст: 24
Tom ест борщ с капустой, но не красный</pre>
   </div>
   <p>
    В данном случае для структуры person определены две функции: print и eat. Функция print выводит информацию о текущем объекте person. А функция 
eat имитирует употребление пищи. Каждая из этих функций определяет объект и тип структуры, к которой функция относится:
   </p>
   <pre class="brush:go;">func (p person) имя_функции</pre>
   <p>
    С помощью объекта p мы можем обращаться к свойствам структуры person. В остальном это обычные функции, которые могут принимать параметры и возвращать результат.
   </p>
   <p>
    Для обращения к функциям структуры указывается переменная структуры и через точку идет вызов функциии.
   </p>
   <pre class="brush:go;">tom.print()
tom.eat("борщ")</pre>
   <p>
    В данном случае tom - это и будет объект
    <code>
     p person
    </code>
    в определении функции.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Методы указателей
   </h2>
   <div class="date">
    Последнее обновление: 26.12.2017
   </div>
   <p>
    При вызове метода, объект структуры, для которого определен метод, передается в него по значению. Что это значит? Рассмотрим следующий пример:
   </p>
   <pre class="brush:go;">package main
import "fmt"

type person struct{
	name string
	age int
}
func (p person) updateAge(newAge int){
	p.age = newAge
}

func main() {
	
	var tom = person { name: "Tom", age: 24 }
	fmt.Println("before", tom.age)
	tom.updateAge(33)
	fmt.Println("after", tom.age)
}</pre>
   <p>
    Для структуры person определен метод updateAge, который принимает параметр newAge и изменяет значение поля age у структуры. То есть при вызове 
этого метода мы ожидаем, что возраст человека изменится. Однако консольный вывод нам показывает, что значение поля age не изменяется:
   </p>
   <div class="console">
    <pre class="consoletext">before 24
after 24</pre>
   </div>
   <p>
    Потому что при вызове
    <code>
     tom.updateAge(33)
    </code>
    метод updateAge получает копию структуры tom. То есть структура tom копируется в другой участок памяти, 
и далее метод updateAge работает с копией, никак не затрагивая оригинальную структуру tom.
   </p>
   <p>
    Однако такое поведение может быть нежелальтельным. Что если мы всетаки хотим таким образом изменять состояние структуры? В этом случае необходимо использовать указатели на структуры:
   </p>
   <pre class="brush:go;">package main
import "fmt"

type person struct{
	name string
	age int
}
func (p *person) updateAge(newAge int){
	(*p).age = newAge
}

func main() {
	
	var tom = person { name: "Tom", age: 24 }
	var tomPointer *person = &amp;tom
	fmt.Println("before", tom.age)
	tomPointer.updateAge(33)
	fmt.Println("after", tom.age)
}</pre>
   <p>
    Теперь метод updateAge принимает указатель на структуру person:
    <code>
     p *person
    </code>
    , то есть фактически адрес структуры в памяти. С помощью операции разыменования получаем значение 
по этому адресу в памяти и меняем поле age:
   </p>
   <pre class="brush:go;">(*p).age = newAge</pre>
   <p>
    В функции main определяем указатель на структуру person и передаем ему адрес структуры tom:
   </p>
   <pre class="brush:go;">var tomPointer *person = &amp;tom</pre>
   <p>
    Затем вызываем метод updateAge:
   </p>
   <pre class="brush:go;">tomPointer.updateAge(33)</pre>
   <p>
    Таким образом, метод updateAge получит адрес, который хранится в tomPointer и по этому адресу обратиться к структуре tom, изменив значение ее свойства age.
   </p>
   <div class="console">
    <pre class="consoletext">before 24
after 33</pre>
   </div>
   <p>
    Стоит отметить, что несмотря на то, что метод updateAge определен для указателя на структуру person, мы по прежнему можем вызывать этот метод и для объекта person:
   </p>
   <pre class="brush:go;">var tom = person { name: "Tom", age: 24 }
fmt.Println("before", tom.age)		// before 24
tom.updateAge(33)
fmt.Println("after", tom.age)		// after 33</pre>
  </div>
  <div class="item center menC">
   <h1>
    Пакеты и модули
   </h1>
   <h2>
    Пакеты и их импорт
   </h2>
   <div class="date">
    Последнее обновление: 24.12.2017
   </div>
   <p>
    Весь код в языке Go организуется в пакеты. Пакеты представляют удобную организацию разделения кода на отдельные части или модули. Модульность позволяет 
определять один раз пакет с нужной функциональностью и потом использовать его многкратно в различных программах.
   </p>
   <p>
    Код пакета располагается в одном или нескольких файлах с расширением
    <span class="b">
     go
    </span>
    . Для определения пакета применяется ключевое слово
    <span class="b">
     package
    </span>
    . Например:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	fmt.Println("Hello Go")
}</pre>
   <p>
    В данном случае пакет называется
    <span class="b">
     main
    </span>
    . Определение пакета должно идти в начале файла.
   </p>
   <p>
    Есть два типа пакетов: исполняемые (executable) и библиотеки (reusable). Для создания исполняемых файлов пакет должен иметь имя
    <span class="b">
     main
    </span>
    . Все остальные пакеты 
не являются исполняемыми. При этом пакет main должен содержать функцию
    <span class="b">
     main
    </span>
    , которая является входной точкой в приложение.
   </p>
   <h3>
    Импорт пакетов
   </h3>
   <p>
    Если уже есть готовые пакеты с нужной нам функциональностью, которую мы хотим использовать, то для их использования мы можем их импортировать в программу с 
помощью оператора
    <span class="b">
     import
    </span>
    . Например, в примере выше задействуется функциональность вывода сообщения на консоль с помощью функции Println, 
которая определена в пакете
    <span class="b">
     fmt
    </span>
    . Соответственно чтобы использовать эту функцию, необходимо импортировать пакет fmt:
   </p>
   <pre class="brush:go;">import "fmt"</pre>
   <p>
    Нередко программы подключают сразу несколько внешних пакетов. В этом случае можно последовательно импортировать каждый пакет:
   </p>
   <pre class="brush:go;">package main
import "fmt"
import "math"

func main() {
	
	fmt.Println(math.Sqrt(16))	// 4
}</pre>
   <p>
    В данном случае подключается встроенный пакет math, который содержит функцию
    <code>
     Sqrt()
    </code>
    , возвращающую квадратный корень числа.
   </p>
   <p>
    Либо чтобы сократить определение импорта пакетов можно заключить все пакеты в скобки:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"math"
)

func main() {
	
	fmt.Println(math.Sqrt(16))
}</pre>
   <p>
    Подобным образом мы можем импортирвать как встроенные пакеты, так и свои собственные. Полный список встроенных пакетов в Go можно найти по адресу
    <a href="https://golang.org/pkg/" rel="nofollow">
     https://golang.org/pkg/
    </a>
    .
   </p>
   <h3>
    Пакет из нескольких файлов
   </h3>
   <p>
    Один пакет может состоять из нескольких файлов. Например, определим в папке два файла:
   </p>
   <img alt="Multiple files in Go build" src="https://metanit.com/go/tutorial/pics/2.1.png"/>
   <p>
    В файле
    <span class="b">
     factorial.go
    </span>
    определим функцию для подсчета факториала:
   </p>
   <pre class="brush:go;">package main

func factorial(n int) int {
	
	var result = 1
	for i:=1; i &lt;= n; i++{
		result *= i
	}
	return result
}</pre>
   <p>
    Данный файл принадлежит пакету main.
   </p>
   <p>
    В файле
    <span class="b">
     main.go
    </span>
    используем функцию для вычисления факториала:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	fmt.Println(factorial(4))
	fmt.Println(factorial(5))
}</pre>
   <p>
    Данный файл также принадлежит пакету main. Файлов может и быть и больше. Теперь скомпилируем из этих файлов программу. Для этого перейдем в 
консоли к папке проекта и выполним команду:
   </p>
   <div class="console">
    <pre class="consoletext">go build -o main.exe factorial.go main.go</pre>
   </div>
   <p>
    Флаг
    <span class="b">
     -o
    </span>
    указывает, как будет называться выходной файл - в данном случае main.exe. Затем идут все компилируемые файлы. После выполнения этой 
команды будет создан файл main.exe, который мы сможем запустить в консоли:
   </p>
   <img alt="Компиляция файлов Go" src="https://metanit.com/go/tutorial/pics/2.2.png"/>
   <h3>
    Файлы в разных пакетах
   </h3>
   <p>
    Теперь рассмотрим другую ситуацию, когда файлы нашей программы разделены по разным пакетам. Определим в папке проекта каталог
    <span class="b">
     computation
    </span>
    . 
Затем в каталог computation добавим следующий файл factorial.go:
   </p>
   <pre class="brush:go;">package computation

func Factorial(n int) int {
	
	var result = 1
	for i:=1; i &lt;= n; i++{
		result *= i
	}
	return result
}</pre>
   <p>
    Код файла factorial.go принадлежит пакету computation. Важно отметить, что название функции начинается с заглавной буквы. Благодаря этому данная 
функция будет видна в других пакетах.
   </p>
   <img alt="Импорт пакетов в Go" src="https://metanit.com/go/tutorial/pics/2.4.png"/>
   <p>
    И чтобы использовать функцию factorial, надо импортировать этот пакет в файле main.go:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"./computation"
)

func main() {
	
	fmt.Println(computation.Factorial(4))
	fmt.Println(computation.Factorial(5))
}</pre>
   <p>
    Путь "./computation" указывает, что пакет находится в папке computation.
   </p>
   <p>
    Компиляция и выполнение программы осуществляется также как и ранее без необходимости указания всех файлов из других пакетов:
   </p>
   <img alt="Компиляция проекта Go из разных пакетов" src="https://metanit.com/go/tutorial/pics/2.3.png"/>
  </div>
  <div class="item center menC">
   <h2>
    Введение в модули
   </h2>
   <div class="date">
    Последнее обновление: 03.12.2021
   </div>
   <p>
    Модули представляют набор пакетов Go, которые имеют встроенное версионирование и которые можем опубликовать для использования в других проектах.
   </p>
   <p>
    Язык Go обладает богатой функциональностью, одной этой встроенной функциониональности может быть недостаточно для постоения приложения. Однако кроме того, 
Go имеет большую экосистему разработчиков, которые разрабатывают и публикуют различные модули. Эти модули могут предоставлять функциональность, которая 
отсутствует во встроенной библиотеке пакетов Go, но которая может быть нам необходима. И Go также позволяет использовать эти модули. Рассмотрим как создавать свои модули и подключать и использовать 
внешние модули в своем приложении. Но, начиная с версии Go 1.16, для использования внешних модулей необходимо определить свой модуль.
   </p>
   <h3>
    Создание модуля
   </h3>
   <p>
    Для создания модуля применяется команда
    <span class="b">
     go mod init
    </span>
    , которой передается имя модуля.
   </p>
   <p>
    Сначала определим папку, где будет располагаться наш модуль. Пусть, к примеру это будет папка
    <span class="b">
     C:\golang\
    </span>
    . Далее перейдем в терминале/командной строке к этой папке. 
Допустим, наш модуль будет называться
    <span class="b">
     helloapp
    </span>
    . Для его создания выполним команду:
   </p>
   <div class="console">
    <pre class="consoletext">go mod init helloapp</pre>
   </div>
   <img alt="go mod init и создание модулей в языке программирования Go" src="https://metanit.com/go/tutorial/pics/modules1.png"/>
   <p>
    После выполнения этой команды в папке появится файл
    <span class="b">
     go.mod
    </span>
    . По умолчанию он будет иметь следующее содержимое:
   </p>
   <pre class="brush:go;">module helloapp

go 1.17</pre>
   <p>
    Первая строка с директивой
    <span class="b">
     module
    </span>
    определяет путь модуля - "helloapp". Вторая строка определяет используемую для модуля версию go - в данном случае 1.17.
   </p>
   <p>
    Кроме пути модуля и версии go этот файл позволяет управлять зависимостями - внешними модулями, которые подключаются в приложение.
   </p>
   <h3>
    Загрузка внешнего модуля
   </h3>
   <p>
    Теперь подключим в наш модуль helloapp внешний модуль. Для примера возьмем модуль "rsc.io/quote". Это модуль, определенный специально для целей тестирования. 
Он содержит набор функций, который возвращают некоторый текст.
   </p>
   <p>
    Для его загрузки модуля "rsc.io/quote" выполним команду:
   </p>
   <div class="console">
    <pre class="consoletext">go get rsc.io/quote</pre>
   </div>
   <p>
    При выполнении этой команды Go загрузит необходимые зависимости:
   </p>
   <img alt="go get загрузка модулей в языке программирования Go" src="https://metanit.com/go/tutorial/pics/modules2.png"/>
   <p>
    Все загужаемые пакеты хранятся по пути
    <span class="b">
     $GOPATH\pkg\mod
    </span>
    . Обычно переменная среды GOPATH указывает на папку
    <span class="ii">
     [Папка текущего пользователя]\go
    </span>
    . 
Например, в моем случае пакеты будут загружаться по адресу
    <span class="ii">
     C:\Users\Eugene\go\pkg\mod
    </span>
   </p>
   <p>
    И если мы заново откроем файл
    <span class="b">
     go.mod
    </span>
    , то мы увидим, что его содержимое изменилось:
   </p>
   <pre class="brush:go;">module helloapp

go 1.17

require (
	golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c // indirect
	rsc.io/quote v1.5.2 // indirect
	rsc.io/sampler v1.3.0 // indirect
)</pre>
   <p>
    В него добавилась директива
    <span class="b">
     require()
    </span>
    , которая содержит определения подключаемых зависимостей. В данном случае это все те зависимости, 
которые необходимы для работы с пакетом "rsc.io/quote".
   </p>
   <p>
    Кроме того, мы также можем заметить, что в папке проекта c:\golang появился еще один файл -
    <span class="b">
     go.sum
    </span>
    с содержимым тиа следуюшего:
   </p>
   <pre class="brush:go;">golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8=
golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
rsc.io/quote v1.5.2 h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3Y=
rsc.io/quote v1.5.2/go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPXsUe+TKr0=
rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=
rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=</pre>
   <p>
    Этот файл содержит контрольную сумму для подключаемых пакетов.
   </p>
   <h3>
    Подключение внешнего модуля
   </h3>
   <p>
    Пакеты из внешнего модуля подключаются также, как и другие пакеты с помощью директивы
    <span class="b">
     import
    </span>
    . Например, 
определим в папке c:\golang собственно файл кода
    <span class="b">
     main.go
    </span>
   </p>
   <img alt="тестирование подключения к внешнему модулю в языке программирования Go" src="https://metanit.com/go/tutorial/pics/modules3.png"/>
   <p>
    Определим в
    <span class="b">
     main.go
    </span>
    следуюшее содержимое:
   </p>
   <pre class="brush:go;">package main

import (
	"fmt"
	"rsc.io/quote"
)

func main() {
	message := quote.Hello()
	fmt.Printf(message)
}</pre>
   <p>
    В данном случае вызывается функция
    <span class="b">
     quote.Hello()
    </span>
    из пакета "rsc.io/quote", которая возвращает некоторое сообщение (точнее строку "Hello World"). 
И в конце запустим программу на выполнение:
   </p>
   <img alt="Подключение к внешнему модулю в языке программирования Go" src="https://metanit.com/go/tutorial/pics/modules4.png"/>
  </div>
  <div class="item center menC">
   <h1>
    Интерфейсы
   </h1>
   <h2>
    Введение в интерфейсы
   </h2>
   <div class="date">
    Последнее обновление: 28.12.2017
   </div>
   <p>
    Интерфейсы представляют абстракцию поведения других типов. Интерфейсы позволяют определять функции, которые не привязаны к конкретной реализации. 
То есть интерфейсы определяют некоторый функционал, но не реализуют его.
   </p>
   <p>
    Для определения интерфейса применяется ключевое слово
    <span class="b">
     interface
    </span>
    :
   </p>
   <pre class="brush:go;">type имя_интерфейса interface{
	определения_функций
}</pre>
   <p>
    Например, простейшее определение интерфейса:
   </p>
   <pre class="brush:go;">type vehicle interface{
	move()
}</pre>
   <p>
    Данный интерфейс называется vehicle. Допустим, данный интерфейс представляет некоторое транспортное средство. 
Он определяет функцию
    <code>
     move()
    </code>
    , которая не принимает никаких параметров и ничего не возвращает.
   </p>
   <p>
    При этом важно понимать, что интерфейс - это именно абстракция, а не конкретный тип, как int, sring или структуры. К примеру, мы не можем напрямую создать объект 
интерфейса:
   </p>
   <pre class="brush:go;">var v vehicle = vehicle{}</pre>
   <p>
    Интерфейс представляет своего рода контракт, которому должен соответствовать тип данных. Чтобы тип данных соответствовал некоторому интерфейсу, 
данный тип должен реализовать в виде методов все функции этого интерфейса. Например, определим две структуры:
   </p>
   <pre class="brush:go;">package main

import "fmt"

type Vehicle interface{
	move()
}

// структура "Автомобиль"
type Car struct{ }

// структура "Самолет"
type Aircraft struct{}


func (c Car) move(){
	fmt.Println("Автомобиль едет")
}
func (a Aircraft) move(){
	fmt.Println("Самолет летит")
}

func main() {
	
	var tesla Vehicle = Car{}
	var boing Vehicle = Aircraft{}
	tesla.move()
	boing.move()
}</pre>
   <p>
    Здесь определены две структуры: Car и Aircraft, которые, предположим, представляют, автомобиль и самолет соответственно. Для каждой из 
структур определен метод
    <code>
     move()
    </code>
    , который имитирует перемещение транспортного средства. Этот метод move соответствует 
функции move интерфейса vehicle по типу параметров и типу возвращаемых значений. Поскольку между методом структур и функций в интерфейсе есть соответствие, 
то подобные структуры неявно реализуют данный интерфейс.
   </p>
   <p>
    В Go интерфейс реализуется
    <span class="b">
     неявно
    </span>
    . Нам не надо специально указывать, что структуры применяют определенный интерфейс, как в 
некоторых других языках программирования. Для реализации типу данных достаточно реализовать методы, которые определяет интерфейс.
   </p>
   <p>
    Поскольку структуры Car и Aircraft реализуют интерфейс Vehicle, то мы можем определить переменные данного интерфейса, передав им объекты структур:
   </p>
   <pre class="brush:go;">var tesla Vehicle = Car{}
var boing Vehicle = Aircraft{}</pre>
   <p>
    Где нам могут помочь интерфейсы? Интерфейсы позволяют определить какую-то обобщенную реализацию без привязки к конкретному типу. 
Например, рассмотрим следующую ситуацию:
   </p>
   <pre class="brush:go;">package main

import "fmt"

type Car struct{ }
type Aircraft struct{}


func (c Car) move(){
	fmt.Println("Автомобиль едет")
}
func (a Aircraft) move(){
	fmt.Println("Самолет летит")
}

func driveCar(c Car){
	c.move()
}
func driveAircraft(a Aircraft){
	a.move()
}

func main() {
	
	var tesla Car = Car{}
	var boing Aircraft = Aircraft{}
	driveCar(tesla)
	driveAircraft(boing)
}
}</pre>
   <p>
    Допустим, в данном случае определены две структуры Car и Aircraft, которые представляют автомобиль и самолет. Для каждой из структур определен метод 
перемещения
    <code>
     move()
    </code>
    , который условно перемещает транспортное средство. И также определены две функции
    <code>
     driveCar()
    </code>
    и
    <code>
     driveAircraft()
    </code>
    , которые принимают соответственно структуры Car и Aircraft и предназначены для вождения этих транспортных средств.
   </p>
   <p>
    И отчетливо видно, что обе функции
    <code>
     driveCar
    </code>
    и
    <code>
     driveAircraft
    </code>
    фактически идентичны, они выполняют один и те же действия, 
только для разных типов. И было бы неплохо, если можно было бы определить одну обобщенную функцию для разных типов. Особенно учитывая, что у нас может быть и больше 
транспортных средств - велосипед, корабль и т.д. И для вождения каждого транспортного средства придется определять свой метод, что не очень удобно. 
И как раз в этом случае можно воспользоваться интерфейсами:
   </p>
   <pre class="brush:go;">package main
import "fmt"

type Vehicle interface{
	move()
}

func drive(vehicle Vehicle){
	vehicle.move()
}

type Car struct{ }
type Aircraft struct{}


func (c Car) move(){
	fmt.Println("Автомобиль едет")
}
func (a Aircraft) move(){
	fmt.Println("Самолет летит")
}

func main() {
	
	tesla := Car{}
	boing := Aircraft{}
	drive(tesla)
	drive(boing)
}</pre>
   <p>
    Теперь вместо двух функций определена одна общая функция -
    <code>
     drive()
    </code>
    , которая в качесте параметра принимает значение типа Vehicle. 
Поскольку этому интерфейсу соответствуют обе структуры Car и Aircraft, то мы можем передавать эти структуры в функцию drive в качесте аргументов.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Соответствие интерфейсу
   </h2>
   <div class="date">
    Последнее обновление: 28.12.2017
   </div>
   <p>
    Чтобы тип данных соответствовал интерфейсу, он должен реализовать все методы этого интерфейса. Например:
   </p>
   <pre class="brush:go;">package main

import "fmt"

type Stream interface{
	read() string
	write(string)
	close()
}

func writeToStream(stream Stream, text string){
	stream.write(text)
}
func closeStream(stream Stream){
	stream.close()
}

// структура файл
type File struct{
	text string
}
// структура папка
type Folder struct{}

// реализация методов для типа *File
func (f *File) read() string{
	return f.text
}
func (f *File) write(message string){
	f.text = message
	fmt.Println("Запись в файл строки", message)
}
func (f *File) close(){
	fmt.Println("Файл закрыт")
}
// релизация методов для типа *Folder
func (f *Folder) close(){
	fmt.Println("Папка закрыта")
}

func main() {
	
	myFile := &amp;File{}
	myFolder := &amp;Folder{}
	
	writeToStream(myFile, "hello world")
	closeStream(myFile)
	//closeStream(myFolder)		// Ошибка: тип *Folder не реализует интерфейс Stream
	myFolder.close()			// Так можно
}</pre>
   <p>
    Здесь определен интерфейс Stream, который условно представляет некоторый поток данных и определяет три метода: close, read и write. И также есть две 
структуры File и Folder, которые представляют соответственно файл и папку. Для типа *File реализованы все три метода интерфейса Stream. А для типа *Folder 
реализован только один метод интерфейса Stream. Поэтому тип *File реализует интерфейс Stream и соответствует этому интерфейсу, а тип *Folder не 
соответствует интерфейсу Stream. Поэтому везде, где требуется объект Stream мы можем использовать объект типа
    <code>
     *File
    </code>
    , но никак не *Folder.
   </p>
   <p>
    Например, в функцию
    <code>
     closeStream()
    </code>
    , которая условно закрывает поток, в качестве параметра передается объект Stream. При вызове в эту функцию 
можно передать объект типа *File, который соответствует интерфейсу Stream:
   </p>
   <pre class="brush:go;">closeStream(myFile)</pre>
   <p>
    А вот объект *Folder передать нельзя:
   </p>
   <pre class="brush:go;">closeStream(myFolder)		// Ошибка: тип *Folder не реализует интерфейс Stream</pre>
   <p>
    Но мы по-прежнему можем вызывать у объекта *Folder метод close, но он будет рассматриваться как собственный метод, который не имеет 
никакого отношения к интерфейсу Stream.
   </p>
   <p>
    Еще важно отметить, что в данном случае методы реализованы именно для типа
    <span class="b">
     *File
    </span>
    , то есть указателя на объект File, 
а не для типа
    <span class="b">
     File
    </span>
    . Это два разных типа. Поэтому тип File по-прежнему НЕ соответствует интерфейсу Stream. И мы, к примеру, 
не можем написать следующее:
   </p>
   <pre class="brush:go;">myFile2 := File{}
closeStream(myFile2)		// ! Ошибка: тип File не соответствует интерфейсу Stream</pre>
   <h3>
    Реализация нескольких интерфейсов
   </h3>
   <p>
    При этом тип данных необязательно должен реализовать только методы интерфейса, для типа данных можно определить его собственные методы или также 
реализовать методы других интерфейсов. Например:
   </p>
   <pre class="brush:go;">package main

import "fmt"

type Reader interface{
	read()
}

type Writer interface{
	write(string)
}

func writeToStream(writer Writer, text string){
	writer.write(text)
}
func readFromStream(reader Reader){
	reader.read()
}

type File struct{
	text string
}

func (f *File) read(){
	fmt.Println(f.text)
}
func (f *File) write(message string){
	f.text = message
	fmt.Println("Запись в файл строки", message)
}

func main() {
	
	myFile := &amp;File{}
	writeToStream(myFile, "hello world")
	readFromStream(myFile)
}</pre>
   <p>
    В данном случае для типа *File реализованы методы обоих интерфейсов - Reader и Writer. Соответственно мы можем использовать объекты типа *File в качестве 
объектов Reader и Writer.
   </p>
   <h3>
    Вложенные интерфейсы
   </h3>
   <p>
    Одни интерфейсы могут содержать другие интерфейсы.
   </p>
   <pre class="brush:go;">type Reader interface{
	read()
}

type Writer interface{
	write(string)
}

type ReaderWriter interface{
	Reader
	Writer
}</pre>
   <p>
    В этом случае для соответствия подобному интерфейсу типы данных должны реализовать все его вложенные интерфейсы. 
Например:
   </p>
   <pre class="brush:go;">package main

import "fmt"

type Reader interface{
	read()
}

type Writer interface{
	write(string)
}

type ReaderWriter interface{
	Reader
	Writer
}

func writeToStream(writer ReaderWriter, text string){
	writer.write(text)
}
func readFromStream(reader ReaderWriter){
	reader.read()
}

type File struct{
	text string
}

func (f *File) read(){
	fmt.Println(f.text)
}
func (f *File) write(message string){
	f.text = message
	fmt.Println("Запись в файл строки", message)
}

func main() {
	
	myFile := &amp;File{}
	writeToStream(myFile, "hello world")
	readFromStream(myFile)
	writeToStream(myFile, "lolly bomb")
	readFromStream(myFile)
}</pre>
   <p>
    В данном случае определено три интерфейса. Причем интерфейс ReaderWriter содержит интерфейсы Reader и Writer. Чтобы структура File соответствовала интерфейсу 
ReaderWriter, она должна реализовать методы read и write, то есть методы обоих вложенных интерфейсов, что в принципе здесь и сделано.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Полиморфизм
   </h2>
   <div class="date">
    Последнее обновление: 06.01.2018
   </div>
   <p>
    Полиморфизм представляет способность принимать многообразные формы. В частности, в предыдущих статьях было рассмотрено использование интерфейсов, 
которым могут соответствовать различные структуры. Например:
   </p>
   <pre class="brush:go;">package main
import "fmt"
 
type Vehicle interface{
    move()
}

type Car struct{ model string}
type Aircraft struct{ model string}
 
 
func (c Car) move(){
    fmt.Println(c.model, "едет")
}
func (a Aircraft) move(){
    fmt.Println(a.model, "летит")
}
 
func main() {
     
	tesla := Car{"Tesla"}
	volvo := Car{"Volvo"}
	boeing := Aircraft{"Boeing"}
	
    vehicles := [...]Vehicle{tesla, volvo, boeing}
	for _, vehicle := range vehicles{
		vehicle.move()
	}
}</pre>
   <p>
    В данном случае определен массив vehicles, который содержит набор структур, которые соответствуют интерфейсу Vehicle, то есть объекты Car и Aircraft. 
То есть объект Vehicle может принимать различные формы: или структуру Car, или структуру Aircraft. При переборе массива для каждого объекта 
вызывается метод move. И в зависимости от реального типа структуры динамически определяется, какая именно реализация метода move для какой структуры 
должна вызываться.
   </p>
   <p>
    Консольный вывод программы:
   </p>
   <div class="console">
    <pre class="consoletext">Tesla едет
Volvo едет
Boeing летит</pre>
   </div>
  </div>
  <div class="item center menC">
   <h1>
    Параллельное программирование. Горутины
   </h1>
   <h2>
    Горутины
   </h2>
   <div class="date">
    Последнее обновление: 12.01.2018
   </div>
   <p>
    Горутины (goroutines) представляют параллельные операции, которые могут выполняться независимо от функции, в которой они запущены. Главная особенность горутин 
состоит в том, что они могут выполняться параллельно. То есть на многоядерных архитектурах есть возможность выполнять отдельные горутины на отдельных 
ядрах процессора, тем самым горутины будут выполняться паралелльно, и программа завершится быстрее.
   </p>
   <p>
    Каждая горутина, как правило, представляет вызов функции, и последовательно выполняет все свои инструкции. Когда мы запускаем программу на Go, мы уже 
работаем как минимум с одной горутиной, которая представлена функцией main. Эта функция последовательно выполняет все инструкции, которые определены внутри нее.
   </p>
   <p>
    Для определения горутин применяется оператор
    <span class="b">
     go
    </span>
    , который ставится перед вызовом функции:
   </p>
   <pre class="brush:go;">go вызов_функции</pre>
   <p>
    Например, определим несколько горутин, вычисляющих факториал числа:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	for i := 1; i &lt; 7; i++{
		go factorial(i)
	}
	fmt.Println("The End")
}

func factorial(n int){
	if(n &lt; 1){
		fmt.Println("Invalid input number")
		return
	}
	result := 1
	for i := 1; i &lt;= n; i++{
		result *= i
	}
	fmt.Println(n, "-", result)
}</pre>
   <p>
    В цикле последовательно запускаются шесть горутин с помощью вызова
    <code>
     go factorial(i)
    </code>
    . То есть фактически это обычный вызов функции с оператором go.
   </p>
   <p>
    Однако вместо шести факториалов на консоли при вызове программы мы можем увидеть только строку "The End":
   </p>
   <div class="console">
    <pre class="consoletext">The End</pre>
   </div>
   <p>
    "Можем увидеть" означает, что поведение программы в данном случае недетерминировано. Например, вывод может быть и таким:
   </p>
   <div class="console">
    <pre class="consoletext">2 - 2
1 - 1
4 - 24
The End
5 - 120</pre>
   </div>
   <p>
    Почему так происходит? После вызова
    <code>
     go factorial(i)
    </code>
    функция main запускает горутину, которая начинает выполняться в своем контексте, независимо от функции main. То есть фактически main и factorial 
выполняются параллельно. Однако главной горутиной является вызов функции main. И если завершается выполнение этой функции, то завершается и выполнение всей программы. 
Поскольку вызовы функции factorial представляют горутины, то функция main не ждет их завершения и после их запуска продолжает свое выполнение. Какие-то горутины могут завершиться раньше функции 
main, и соответственно мы сможем увидеть на консоли их результат. Но может сложиться ситуация, что функция main выполнится раньше вызовов функции factorial. Поэтому мы можем не увидеть на консоли факториалы чисел.
   </p>
   <p>
    Чтобы все таки увидеть результат выполнения горутин, поставим в конце функции main вызов функции
    <code>
     fmt.Scanln()
    </code>
    , которая ожидает ввода пользователя с консоли:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	for i := 1; i &lt; 7; i++{
		go factorial(i)
	}
	fmt.Scanln()		// ждем ввода пользователя
	fmt.Println("The End")
}

func factorial(n int){
	if(n &lt; 1){
		fmt.Println("Unvalid input number")
		return
	}
	result := 1
	for i := 1; i &lt;= n; i++{
		result *= i
	}
	fmt.Println(n, "-", result)
}</pre>
   <p>
    Теперь мы сможем увидеть результаты всех вызовов функции factorial:
   </p>
   <div class="console">
    <pre class="consoletext">1 - 1
3 - 6
5 - 120
4 - 24
2 - 2
6 - 720

The End</pre>
   </div>
   <p>
    Стоит отметить, что так как каждая горутина запускается в своем собственном контексте и выполняется независимо и паралелльно по сравнению с другими горутинами, 
то в данном случае нельзя четко детерминировать, какая из горутин завершится раньше. Например, горутина
    <code>
     go factorial(2)
    </code>
    запускается 
до
    <code>
     go factorial(5)
    </code>
    , однако может завершиться после.
   </p>
   <p>
    Горутины также могут представлять вызовы анонимных функций:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	for i := 1; i &lt; 7; i++{
		
		go func(n int){
			result := 1
			for j := 1; j &lt;= n; j++{
				result *= j
			}
			fmt.Println(n, "-", result)
		}(i)
	}
	fmt.Scanln()
	fmt.Println("The End")
}</pre>
  </div>
  <div class="item center menC">
   <h2>
    Каналы
   </h2>
   <div class="date">
    Последнее обновление: 23.02.2024
   </div>
   <p>
    Каналы (channels) представляют инструменты коммуникации между горутинами. Для определения канала применяется ключевое слово
    <span class="b">
     chan
    </span>
    :
   </p>
   <pre class="brush:go;">chan тип_элемента</pre>
   <p>
    После слова
    <code>
     chan
    </code>
    указывается тип данных, которые будут передаться с помощью канала. Например:
   </p>
   <pre class="brush:go;">var intCh chan int</pre>
   <p>
    Здесь переменная intCh представляет канал, который передает данные типа int.
   </p>
   <p>
    Для передачи данных в канал или, наоборот, из канала применяется операция
    <span class="b">
     &lt;-
    </span>
    (направленная влево стрелка). Например, передача данных в канал:
   </p>
   <pre class="brush:go;">intCh &lt;- 5</pre>
   <p>
    В данном случае в канал посылается число 5. Получение данных из канала в переменную:
   </p>
   <pre class="brush:go;">val := &lt;- intCh</pre>
   <p>
    Если ранее в канал было отправлено число 5, то при выполнении операции
    <code>
     &lt;- intCh
    </code>
    мы можем получить это число в переменную val.
   </p>
   <p>
    Стоит учитывать, что мы можем отправить в канал и получить из канала данные только того типа, который представляет канал. Так, в примере с каналом intCh это данные типа int.
   </p>
   <p>
    Как правило, отправителем данных является одна горутина, а получателем - другая горутина.
   </p>
   <p>
    При простом определении переменной канала она имеет значение
    <span class="b">
     nil
    </span>
    , то есть по сути канал неинициализирован. Для инициализации 
применяется функция
    <span class="b">
     make()
    </span>
    . В зависимости от определения емкости канала он может быть буферизированным или небуферизированным.
   </p>
   <h3>
    Небуфферизированные каналы
   </h3>
   <p>
    Для создания небуферизированного канала вызывается функция
    <code>
     make()
    </code>
    без указания емкости канала:
   </p>
   <pre class="brush:go;">var intCh chan int = make(chan int)	// канал для данных типа int
strCh := make(chan string)	// канал для данных типа string</pre>
   <p>
    Если канал пустой, то горутина-получатель блокируется, пока в канале не окажутся данные. Когда горутина-отправитель посылает данные, 
горутина-получатель получает эти данные и возобновляет работу.
   </p>
   <p>
    Горутина-отправитель может отправлять данные только в пустой канал. Горутина-отправитель блокируется до тех пор, пока данные из канала не будут получены. Например:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	intCh := make(chan int) 
	
	go func(){
			fmt.Println("Go routine starts")
			intCh &lt;- 5 // блокировка, пока данные не будут получены функцией main
	}()
	fmt.Println(&lt;-intCh)	// получение данных из канала
	fmt.Println("The End")
}</pre>
   <p>
    Через небуферизированный канал intCh горутина, представленная анонимной функцией, передает число 5:
   </p>
   <pre class="brush:go;">intCh &lt;- 5</pre>
   <p>
    А функция main получает это число:
   </p>
   <pre class="brush:go;">fmt.Println(&lt;-intCh)</pre>
   <p>
    Общий ход выполнения программы выглядит следующим образом:
   </p>
   <ol>
    <li>
     <p>
      Запускается функция main. Она создает канал intCh и запускает горутину в виде анонимной функции.
     </p>
    </li>
    <li>
     <p>
      Функция main продолжает выполняться и блокируется на строке
      <code>
       fmt.Println(&lt;-intCh)
      </code>
      , пока не будут получены данные.
     </p>
    </li>
    <li>
     <p>
      Параллельно выполняется запущенная горутина в виде анонимной функции. В конце своего выполнения она отправляет даные через канал:
      <code>
       intCh &lt;- 5
      </code>
      . Горутина блокируется, 
пока функция main не получит данные.
     </p>
    </li>
    <li>
     <p>
      Функция main получает отправленные данные, деблокируется и продолжает свою работу.
     </p>
    </li>
   </ol>
   <p>
    В данном случае горутина определена в виде анонимной функции и поэтому она имеет доступ к окружению, в том числе к переменной intCh. Если же мы работаем с обычными функциями, 
то объекты каналов надо передавать через параметры:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	intCh := make(chan int) 
	
	go factorial(5, intCh)	// вызов горутины
	fmt.Println(&lt;-intCh)	// получение данных из канала
	fmt.Println("The End")
}

func factorial(n int, ch chan int){
	
	result := 1
	for i := 1; i &lt;= n; i++{
		result *= i
	}
	fmt.Println(n, "-", result)
	
	ch &lt;- result		// отправка данных в канал
}</pre>
   <p>
    Обратите внимание, как определяется параметр, который представляет канал данных типа int:
    <code>
     ch chan int
    </code>
    . Консольный вывод данной программы:
   </p>
   <div class="console">
    <pre class="consoletext">5 - 120
120
The End</pre>
   </div>
   <p>
    Таким образом, при использовании канала вызывающий поток - функция main ожидает завершения выполнения горутины.
   </p>
   <p>
    Стоит отметить, что одномоментно одна горутина должеа отправлять данные, а другая - получать. Например, если мы определим отправление и получение данных через 
канал в самой функции main, то мы столкнемся с взаимоблокировкой:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	intCh := make(chan int) 
	intCh &lt;- 10		// функция main блокируется
	fmt.Println(&lt;-intCh)
}</pre>
   <p>
    От этой ситуации следует отличать ситуацию, когда две горутины попеременно обмениваются данными, при этом одномоментно опять же одна горутина выступает отправителем, а другая - получателем. Например:
   </p>
   <pre class="brush:go;">package main
import "fmt"
 
 
func main() {
     
    intCh := make(chan int) 

    go square(intCh)        // square ожидает получения через канал
    intCh &lt;- 4              // отправляем в канал число
    fmt.Println("result := ", &lt;-intCh)  // получаем из канала результат
    fmt.Println("The End")
}
// функция возведения в квадрат
func square(ch chan int){
     
    num := &lt;-ch                 // получаем из канала число
    fmt.Println("num := ", num)
    ch &lt;- num * num             // обратно отправляем квадрат числа
}</pre>
   <p>
    Здесь определена функция square, которая получает через канал число, возводит его в квадрат и возвращает обратно в канал. Функция main запускает функцию square в виде горутины, 
отправляет в канал некоторое число и ожидает получить в ответ из канала квадрат этого числа.
   </p>
   <p>
    В итоге сначала запускается горутина square:
   </p>
   <pre class="brush:go;">go square(intCh)</pre>
   <p>
    Горутина square блокируется на строке
   </p>
   <pre class="brush:go;">num := &lt;-ch</pre>
   <p>
    В этот момент получателем является горутина square, а отправителем функция main. И функция main отправляет данные в поток:
   </p>
   <pre class="brush:go;">intCh &lt;- 4</pre>
   <p>
    После этого горутина square получает из канала число, и роли меняются: теперь отправителем становится горутина square, а получателем - функция main, которая в ожидании данных блокируется на строке
   </p>
   <pre class="brush:go;">fmt.Println("result := ", &lt;-intCh)</pre>
   <p>
    Функция square обрабатывает полученное число и отправляет квадрат числа в поток:
   </p>
   <pre class="brush:go;">ch &lt;- num * num</pre>
   <p>
    Функция main получает из канала квадрат числа и завершает свою работу. Консольный вывод программы:
   </p>
   <pre class="sh">num :=  4
result :=  16
The End</pre>
   <h3>
    Буферизированные каналы
   </h3>
   <p>
    Буферизированные каналы также создаются с помощью функции
    <code>
     make()
    </code>
    , только в качестве второго аргумента в функцию передается емкость канала. 
Если канал пуст, то получатель ждет, пока в канале появится хотя бы один элемент.
   </p>
   <p>
    При отправке данных горутина-отправитель ожидает, пока в канале не освободится место для еще одного элемента и отправляет элемент, только тогда, когда в канале освобождается для него место.
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	intCh := make(chan int, 3) 
	intCh &lt;- 10
	intCh &lt;- 3
	intCh &lt;- 24
	fmt.Println(&lt;-intCh)		// 10
	fmt.Println(&lt;-intCh)		// 3
	fmt.Println(&lt;-intCh)		//24
}</pre>
   <p>
    В данном случае отправителем и получателем данных является функция main. В ней создается канал из трех элементов, и последовательно отправляются три значения типа int.
   </p>
   <p>
    В то же время в данном случае должно быть соответствие между количеством отправляемых и получаемых данных. Если в функции main будет одновременно отправлено 
значений больще, чем вмещает канал, то функция заблокируется:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	intCh := make(chan int, 3) 
	intCh &lt;- 10
	intCh &lt;- 3
	intCh &lt;- 24
	intCh &lt;- 15	// блокировка - функция main ждет, когда освободится место в канале
	
	fmt.Println(&lt;-intCh)
	fmt.Println("The End")
}</pre>
   <p>
    С помощью встроенных функций
    <span class="b">
     cap()
    </span>
    и
    <span class="b">
     len()
    </span>
    можно получить соответственно емкость и количество элементов в канале:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	intCh := make(chan int, 3) 
	intCh &lt;- 10
	
	fmt.Println(cap(intCh))		// 3
	fmt.Println(len(intCh))		// 1
	
	fmt.Println(&lt;-intCh)
}</pre>
   <h3>
    Однонаправленные каналы
   </h3>
   <p>
    В Go можно определить канал, как доступный только для отправки данных или только для получения данных.
   </p>
   <p>
    Определение канала только для отправки данных:
   </p>
   <pre class="brush:go;">var inCh chan&lt;- int</pre>
   <p>
    Определение канала только для получения данных:
   </p>
   <pre class="brush:go;">var outCh &lt;-chan int</pre>
   <p>
    Например:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	intCh := make(chan int, 2) 
	go factorial(5, intCh)
	fmt.Println(&lt;-intCh)
	fmt.Println("The End")
}

func factorial(n int, ch chan&lt;- int){
	
	result := 1
	for i := 1; i &lt;= n; i++{
		result *= i
	}
	ch &lt;- result
}</pre>
   <p>
    Здесь второй параметр функции factorial определен как канал, доступный только для отправки данных:
    <code>
     ch chan&lt;- int
    </code>
    . Соответственно 
внутри функции factorial мы можем только отправлять данные в канал, но не получать их.
   </p>
   <h3>
    Возвращение канала
   </h3>
   <p>
    Канал может быть возвращаемым значением функции. Однако следует внимательно подходить к операциям записи и чтения в возвращаемом канале. Например:
   </p>
   <pre class="brush:go;">package main
import "fmt"
 
func main() {
	fmt.Println("Start")
	 // создание канала и получение из него данных
	fmt.Println(&lt;-createChan(5))	// блокировка
    fmt.Println("End")
}
func createChan(n int) chan int{
	ch := make(chan int)	// создаем канал
	ch &lt;- n		// отправляем данные в канал
    return ch	// возвращаем канал
}</pre>
   <p>
    Функция createChan возвращает канал. Однако при выполнении операции
    <code>
     ch &lt;- n
    </code>
    мы столкнемся с блокировкой, поскольку происходит ожидание 
получения данных из канала. Поэтому следующее выражение
    <code>
     return ch
    </code>
    не будет выполняться.
   </p>
   <p>
    И если все таки необходимо определить функцию, которая возвращает канал, то все операции чтения-записи в канал следует вынести в отдельную горутину:
   </p>
   <pre class="brush:go;">package main
import "fmt"
 
func main() {
	fmt.Println("Start")
	 // создание канала и получение из него данных
	fmt.Println(&lt;-createChan(5))	// 5
    fmt.Println("End")
}
func createChan(n int) chan int{
	ch := make(chan int)	// создаем канал
	go func(){
		ch &lt;- n		// отправляем данные в канал
	}()				// запускаем горутину
    return ch	// возвращаем канал
}</pre>
  </div>
  <div class="item center menC">
   <h2>
    Закрытие канала
   </h2>
   <div class="date">
    Последнее обновление: 12.01.2018
   </div>
   <p>
    После инициализации канал готов передавать данные. Он находится в открытом состоянии, и мы можем с ним взаимодействовать, пока не будет закрыт с помощью встроенной функции
    <span class="b">
     close()
    </span>
    :
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	intCh := make(chan int, 3) 
	intCh &lt;- 10
	intCh &lt;- 3
	close(intCh)
	// intCh &lt;- 24		// ошибка - канал уже закрыт
	fmt.Println(&lt;-intCh)		// 10
	fmt.Println(&lt;-intCh)		// 3
	fmt.Println(&lt;-intCh)		// 0
}</pre>
   <p>
    После закрытия канала мы не сможем послать в него новые данные. Если мы попробуем это сделать, то получим ошибку. Однако мы можем получить ранее добавленные данные. 
Но при попытке получить данные из канала, которых нет, мы получим значение по умолчанию. Например, в примере выше в канал добавляются два значения. При попытке получить 
третье значение, которого нет в канале, мы получим значение по умолчанию - число 0.
   </p>
   <p>
    Чтобы не столкнуться с проблемой, когда канал уже закрыт, мы можем проверять состояние канала. В частности, из канала мы можем получить два значения:
   </p>
   <pre class="brush:go;">val, opened:= &lt;-intCh</pre>
   <p>
    Первое значение - val - это собственно данные из канала, а opened представляет логическое значение, которое равно true, если канал открыт и мы можем успешно считать из него данные. Например, 
мы можем проверять с помощью условной конструкции состояние канала:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() {
	
	intCh := make(chan int, 3) 
	intCh &lt;- 10
	intCh &lt;- 3
	close(intCh)	// канал закрыт
	
	for i := 0; i &lt; cap(intCh); i++ { 
         if val, opened := &lt;-intCh; opened { 
			fmt.Println(val) 
         } else { 
			fmt.Println("Channel closed!") 
         } 
   }
}</pre>
   <p>
    Консольный вывод программы:
   </p>
   <div class="console">
    <pre class="consoletext">10
3
Channel closed!</pre>
   </div>
  </div>
  <div class="item center menC">
   <h2>
    Синхронизация
   </h2>
   <div class="date">
    Последнее обновление: 12.01.2018
   </div>
   <p>
    Использование каналов открывает нам возможности по синхронизации между различными горутинами. Например, одна горутина производит некоторое действие, результат которой 
используется в другой горутине. В этом плане мы можем использовать каналы для синхронизации. Например, одна горутина вычисляет факториал числа, а результат 
выводится в другой горутине:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() { 
   
   intCh := make(chan int)
 
   go factorial(5, intCh)
   
   fmt.Println(&lt;-intCh)
}

func factorial(n int, ch chan int){
	result := 1
	for i:=1; i &lt;= n; i++{
		result *= i
	}
	ch &lt;- result
}</pre>
   <p>
    Канал не обязательно должен нести данные, которые представляют некоторый результат, от которого зависит дальнейшее выполнение горутины. Иногда это может быть 
холостой объект, например, пустая структура, которая необходима только для синхронизации горутин:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main() { 
   
   results := make(map[int]int)
   structCh := make(chan struct{})
 
   go factorial(5, structCh, results)
   
   &lt;-structCh		// ожидаем закрытия канала structCh
   
   for i, v := range results{
	fmt.Println(i, " - ", v)
   }
}

func factorial(n int, ch chan struct{}, results map[int]int){
	defer close(ch)		// закрываем канал после завершения горутины
	result := 1
	for i:=1; i &lt;= n; i++{
		result *= i
		results[i] = result
	}
}</pre>
   <p>
    В данном случае функция factorial по-прежнему вычисляет факториал, но помещает все факториалы чисел от 1 до n в отображение results, где 
ключи представляют числа, а значения - факториалы чисел.
   </p>
   <p>
    Канал, через который горутины взаимодействуют, представляет тип
    <code>
     chan struct{}
    </code>
    . Причем функция factorial не отправляе конкретные данные в канал, а просто закрывает его после 
выполнения всех своих инструкций с помощью вызова
    <code>
     defer close(ch)
    </code>
    . После закрытия канала в функции main получает соответствующий сигнал в строке
    <code>
     &lt;-structCh
    </code>
    , и 
после этого функция main продолжает свою работу.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Передача потоков данных
   </h2>
   <div class="date">
    Последнее обновление: 12.01.2018
   </div>
   <p>
    Нередко одна горутина транслирует другой горутине через канал не одиночные значения, а некоторый поток данных. В этом случае общий алгоритм состоит в том, что горутина-отправитель в течение 
некоторого периода отправляет данные. Когда данные для отправки закончились, работа сделала, отправитель закрывает канал.
   </p>
   <p>
    Горутина-получатель в бесконечном цикле получает данные из канала. Если будет получен маркер закрытия канала, то осуществляется выход из бесконечного цикла.
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main(){
   intCh := make(chan int) 
   
   go factorial(7, intCh)
 
   for { 
         num, opened := &lt;- intCh 	// получаем данные из потока
         if !opened { 
               break 	// если поток закрыт, выход из цикла
         } 
         fmt.Println(num)
   }
}

func factorial(n int, ch chan int){
	defer close(ch)
	result := 1
	for i := 1; i &lt;= n; i++{
		result *= i
		ch &lt;- result		// посылаем по числу
	}
}</pre>
   <p>
    В данном случае функция main и горутина factorial взаимодействуют через канал intCh. Функция factorial последовательно вычисляем факториалы чисел от 1 до n. 
И все вычисленные значения передаются в канал. По завершении функции factorial канал закрывается вызывом
    <code>
     defer close(ch)
    </code>
    .
   </p>
   <p>
    В функции main в бесконечом цикле отправленные данные извлекаются из канала. При этом также проверяется, открыт ли канал. И ели вдруг канал закрыт и соответственно нет смысла получать 
из него данные, происходит выход из бесконечного цикла:
   </p>
   <pre class="brush:go;">for { 
	num, opened := &lt;- intCh 
	if !opened { 
		break 
	} 
	fmt.Println(num)
}</pre>
   <p>
    Консольный вывод программы:
   </p>
   <div class="console">
    <pre class="consoletext">1
2
6
24
120
720
5040</pre>
   </div>
   <p>
    При извлечении значений из канала мы можем использовать ту же форму цикла for, которая применяется для перебора коллекций:
   </p>
   <pre class="brush:go;">for переменная := канал{
	//...........
}</pre>
   <p>
    Например, перепишем предыдущий пример:
   </p>
   <pre class="brush:go;">package main
import "fmt"

func main(){
   intCh := make(chan int) 
   
   go factorial(7, intCh)
 
	for num := range intCh{
		fmt.Println(num)
	}
}

func factorial(n int, ch chan int){
	defer close(ch)
	result := 1
	for i := 1; i &lt;= n; i++{
		result *= i
		ch &lt;- result
	}
}</pre>
   <p>
    Когда канал будет закрыт, то автоматически произойдет выход из цикла for.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Мьютексы
   </h2>
   <div class="date">
    Последнее обновление: 12.01.2018
   </div>
   <p>
    Для упрощения синхронизации между горутинами в Go имеется пакет
    <span class="b">
     sync
    </span>
    , который предоставляет ряд возможностей, в частности мьютексы. 
Мьютексы позволяют разграничить доступ к некоторым общим ресурсам, гарантируя, что только одна горутина имеет к ним доступ в определенный момент времени. И пока одна горутина не освободит 
общий ресурс, другая горутина не может с ним работать.
   </p>
   <p>
    На уровне кода мьютекс представляет тип
    <span class="b">
     sync.Mutex
    </span>
    . Для блокирования доступа к общему разделяемому ресурсу у мьютекса вызывается метод
    <span class="b">
     Lock()
    </span>
    , а для разблокировки доступа - метод
    <span class="b">
     Unlock()
    </span>
    .
   </p>
   <p>
    В какой ситуации нам могут помочь мьютексы? Рассмотрим следующую ситуацию:
   </p>
   <pre class="brush:go;">package main
import "fmt"

var counter int = 0				//	общий ресурс
func main() {

	ch := make(chan bool)		 // канал
	for i := 1; i &lt; 5; i++{
		go work(i, ch)
	}
	// ожидаем завершения всех горутин
	for i := 1; i &lt; 5; i++{
		&lt;-ch
	}
	fmt.Println("The End")
}
func work (number int, ch chan bool){
	counter = 0
	for k := 1; k &lt;= 5; k++{
		counter++
		fmt.Println("Goroutine", number, "-", counter)
	}
	ch &lt;- true
}</pre>
   <p>
    Функция work сбрасывает значение переменной counter к нулю и в цикле последовательно увеличивает ее значение до 5. В функции main запускается четыре горутин work. 
Но какой в данном случае будет консольный вывод? Он может быть, например, таким:
   </p>
   <div class="console">
    <pre class="consoletext">Goroutine 3 - 1
Goroutine 3 - 2
Goroutine 3 - 3
Goroutine 3 - 4
Goroutine 3 - 5
Goroutine 2 - 1
Goroutine 2 - 6
Goroutine 2 - 7
Goroutine 2 - 8
Goroutine 2 - 9
Goroutine 1 - 1
Goroutine 1 - 10
Goroutine 1 - 11
Goroutine 1 - 12
Goroutine 1 - 13
Goroutine 4 - 1
Goroutine 4 - 14
Goroutine 4 - 15
Goroutine 4 - 16
Goroutine 4 - 17
The End</pre>
   </div>
   <p>
    Несмотря на то, что в каждой горутине значение counter сбрасывается к 0, а затем увеличивается до 5, мы видим, что несколько горутин после сброса переменной работают совсем с другим значением. То есть 
при запуске горутин каждая из них получает значение переменной counter и начинает с ней работать. Пока одна горутина еще не закончила работу с counter в цикле, с этой же переменной начинает работать и 
другая горутина. То есть к одному и тому же разделяемому общему ресурсу - переменной counter одновременно работают сразу несколько горутин. Это может привести к некорректным результатам, 
как в данном случае.
   </p>
   <p>
    С помощью мьютексов можно ограничить доступ к переменной таким образом, чтобы только одна горутина имела к ней монопольный доступ в один момент времени:
   </p>
   <pre class="brush:go;">package main
import (
"fmt"
"sync"
)

var counter int = 0				//	общий ресурс
func main() {

	ch := make(chan bool)		// канал
	var mutex sync.Mutex		// определяем мьютекс
	for i := 1; i &lt; 5; i++{
		go work(i, ch, &amp;mutex)
	}
	
	for i := 1; i &lt; 5; i++{
		&lt;-ch
	}
	
	fmt.Println("The End")
}
func work (number int, ch chan bool, mutex *sync.Mutex){
	mutex.Lock()	// блокируем доступ к переменной counter
	counter = 0
	for k := 1; k &lt;= 5; k++{
		counter++
		fmt.Println("Goroutine", number, "-", counter)
	}
	mutex.Unlock()	// деблокируем доступ
	ch &lt;- true
}</pre>
   <p>
    Теперь функция work принимает указатель на мьютекс. С помощью вызова
    <code>
     mutex.Lock()
    </code>
    мьютекс блокируется данной горутиной. Это значит, что к 
последующему коду имеет доступ только та горутина, которая первая заблокировала мьютекс. Остальные горутины ждут пока, мьютекс освободится.
   </p>
   <p>
    Далее горутина сбрасывает значение переменной counter к нулю и затем в цикле последовательно увеличивает его. В конце, когда все действия с общим ресурсом 
уже выполнены, горутина освобождает мьютекс с помощью вызова
    <code>
     mutex.Unlock()
    </code>
    . Ожидающие горутины получают сигнал, что мьютекс освободился, и одна из горутин 
блокирует мьютекс и начинает выполнять действия с переменной counter. И так далее горутины последовательно захватывают и освобождают мьютекс. В итоге к следующей секции:
   </p>
   <pre class="brush:go;">mutex.Lock()	// блокируем доступ к переменной counter
counter = 0
for k := 1; k &lt;= 5; k++{
	counter++
	fmt.Println("Goroutine", number, "-", counter)
}
mutex.Unlock()	// деблокируем доступ</pre>
   <p>
    будет иметь доступ только та горутина, которая первая заблокировала мьютекс. В итоге мы получим следующий результат:
   </p>
   <div class="console">
    <pre class="consoletext">Goroutine 1 - 1
Goroutine 1 - 2
Goroutine 1 - 3
Goroutine 1 - 4
Goroutine 1 - 5
Goroutine 4 - 1
Goroutine 4 - 2
Goroutine 4 - 3
Goroutine 4 - 4
Goroutine 4 - 5
Goroutine 3 - 1
Goroutine 3 - 2
Goroutine 3 - 3
Goroutine 3 - 4
Goroutine 3 - 5
Goroutine 2 - 1
Goroutine 2 - 2
Goroutine 2 - 3
Goroutine 2 - 4
Goroutine 2 - 5
The End</pre>
   </div>
  </div>
  <div class="item center menC">
   <h2>
    WaitGroup
   </h2>
   <div class="date">
    Последнее обновление: 09.02.2020
   </div>
   <p>
    Еще одну возможность по синхронизации горутин представляет использование типа
    <span class="b">
     sync.WaitGroup
    </span>
    . Этот тип позволяет определить группу горутин, 
которые должны выполняться вместе как одна группа. И можно установить блокировку, которая приостановит выполнение функции, пока не завершит выполнение 
вся группа горутин. Например:
   </p>
   <pre class="brush:go;">package main
import (
"fmt"
"sync"
"time"
)
 
   
func main() { 
    var wg sync.WaitGroup 
    wg.Add(2)       // в группе две горутины
    work := func(id int) { 
        defer wg.Done()
		fmt.Printf("Горутина %d начала выполнение \n", id) 
		time.Sleep(2 * time.Second)
		fmt.Printf("Горутина %d завершила выполнение \n", id) 
   } 
  
   // вызываем горутины
   go work(1) 
   go work(2) 
  
   wg.Wait()        // ожидаем завершения обоих горутин
   fmt.Println("Горутины завершили выполнение") 
}</pre>
   <p>
    Вначале определяем группу в виде переменной
    <code>
     wg sync.WaitGroup
    </code>
    . С помощью метода Add определяем, что группа будет состоять из двух элементов:
   </p>
   <pre class="brush:go;">wg.Add(2)</pre>
   <p>
    Число, которое передается в метод Add определяет значение внутреннего счетчика активных элементов.
   </p>
   <p>
    Все элементы группы wg будут представлять анонимную функцию в виде переменной work, которая в качестве параметра принимает условный числовой идентификатор горутины. 
Эта функция будет вызываться в виде горутин. Чтобы сигнализировать, что элемент группы завершил свое выполнение, в горутине необходимо вызвать метод
    <code>
     Done()
    </code>
    :
   </p>
   <pre class="brush:go;">defer wg.Done()</pre>
   <p>
    Вызов метода wg.Done() уменьшает внутренний счетчик активных элементов на единицу.
   </p>
   <p>
    В самой функции
    <code>
     work()
    </code>
    с помощью задержки времени на две секунды (
    <code>
     time.Sleep(2 * time.Second)
    </code>
    ) имитируется работа горутины
   </p>
   <p>
    Далее вызываем две горутины:
   </p>
   <pre class="brush:go;">go work(1) 
go work(2)</pre>
   <p>
    Причем количество горутин, которые вызывают метод
    <code>
     wg.Done()
    </code>
    должно соответствовать количеству элементов группы wg, то есть в данном случае 2 элемента.
   </p>
   <p>
    Затем вызывается метод
    <code>
     Wait()
    </code>
    , который ожидает завершения всех горутин из группы wg:
   </p>
   <pre class="brush:go;">wg.Wait()</pre>
   <p>
    Метод деблокирует функцию main, когда внутренний счетчик активных элементов в группе wg стает равен 0. Поэтому когда все горутины из группы wg завершат 
выполнение, функция main продолжит свою работу.
   </p>
   <p>
    Результат работы программы:
   </p>
   <div class="console">
    <pre class="consoletext">Горутина 1 начала выполнение
Горутина 2 начала выполнение
Горутина 1 завершила выполнение
Горутина 2 завершила выполнение
Горутины завершили выполнение</pre>
   </div>
  </div>
  <div class="item center menC">
   <h1>
    Потоки и файлы
   </h1>
   <h2>
    Операции ввода-вывода. Reader и Writer
   </h2>
   <div class="date">
    Последнее обновление: 15.01.2018
   </div>
   <p>
    Язык Go имеет свою модель работы с потоками ввода-вывода, которая позволяет получать данные из различных источников - файлов, сетевых интерфейсов, объектов в памяти и т.д.
   </p>
   <p>
    Поток данных в Go представлен байтовым срезом ([]byte), из которого можно считывать байты или в который можно заносить данные. Ключевыми типами для работы с потоками 
являются интерфейсы
    <span class="b">
     Reader
    </span>
    и
    <span class="b">
     Writer
    </span>
    из пакета
    <a href="https://golang.org/pkg/io/" rel="nofollow">
     io
    </a>
    .
   </p>
   <h3>
    io.Reader
   </h3>
   <p>
    Интерфейс
    <span class="b">
     io.Reader
    </span>
    предназначен для считывания данных. Он имеет следующее определение:
   </p>
   <pre class="brush:go;">type Reader interface { 
	Read(p []byte) (n int, err error) 
}</pre>
   <p>
    Метод Read возвращает общее количество считанных байт из среза байт и информацию об ошибке, если она возникнет. Если в потоке больше нет данных, 
то метод должен возвращать ошибку типа
    <span class="b">
     io.EOF
    </span>
    .
   </p>
   <p>
    Рассмотрим простейший пример. Например, нам необходимо считывать номера телефонов, которые могут иметь различные форматы:
   </p>
   <pre class="brush:go;">package main
import (
"fmt"
"io"
)

type phoneReader string

func (ph phoneReader) Read(p []byte) (int, error){
	count := 0
	for i := 0; i &lt; len(ph); i++{
		if(ph[i] &gt;= '0' &amp;&amp; ph[i] &lt;= '9'){
			p[count] = ph[i]
			count++
		}
	}
	return count, io.EOF
}

func main() { 
	phone1 := phoneReader("+1(234)567 9010")
	phone2 := phoneReader("+2-345-678-12-35")
	
	buffer := make([]byte, len(phone1))
	phone1.Read(buffer)
	fmt.Println(string(buffer))		// 12345679010
	
	buffer = make([]byte, len(phone2))
	phone2.Read(buffer)
	fmt.Println(string(buffer))		// 23456781235
}</pre>
   <p>
    Для считывания номеров телефонов определен тип phoneReader, который по сути представляет тип string. Однако phoneReader при этом реализует интерфейс Reader, 
то есть определяет его метод Read. В методе Read считываем данные из строки, которую представляет объект phoneReader и, если символы строки представляют числовые данные, передаем их в 
срез байтов. На выходе возвращаем количество считанных данных и маркер окончания чтения io.EOF. В результате при считывании из строки метод Read возвратит номер телефона, который состоит только из цифр.
   </p>
   <p>
    При вызове метода Read создается срез байтов достаточной длины, который передается в метод Read:
   </p>
   <pre class="brush:go;">buffer := make([]byte, len(phone1))
phone1.Read(buffer)</pre>
   <p>
    Затем с помощью инициализатора string мы можем преобразовать срез байтов в строку:
   </p>
   <pre class="go;">fmt.Println(string(buffer))		// 12345679010</pre>
   <h3>
    io.Writer
   </h3>
   <p>
    Интерфейс
    <span class="b">
     io.Writer
    </span>
    предназначен для записи в поток. Он определяет метод
    <span class="b">
     Write()
    </span>
    :
   </p>
   <pre class="brush:go;">type Writer interface { 
	Write(p []byte) (n int, err error) 
}</pre>
   <p>
    Метод Write предназначен для копирования данных их среза байт p в определенный ресурс - файл, сетевой интерфейс и т.д. Метод возвращает количество записанных байтов и 
объект ошибки.
   </p>
   <p>
    Рассмотрим примитивный пример:
   </p>
   <pre class="brush:go;">package main
import "fmt"

type phoneWriter struct{ }

func (p phoneWriter) Write(bs []byte) (int, error){
	if len(bs) == 0 { 
         return 0, nil 
   }
   for i := 0; i &lt; len(bs); i++{
		if(bs[i] &gt;= '0' &amp;&amp; bs[i] &lt;= '9'){
			fmt.Print(string(bs[i]))
		}
	}
	fmt.Println()
	return len(bs), nil
}

func main() { 
	bytes1 := []byte("+1(234)567 9010")
	bytes2 := []byte("+2-345-678-12-35")
	
	writer := phoneWriter{}
	writer.Write(bytes1)
	writer.Write(bytes2)
}</pre>
   <p>
    Здесь структура phoneWriter реализует интерфейс Writer. В методе Write она принимает срез байтов. Предполагается, что срез байтов хранит номер телефона. 
Эта информация должным образом обрабатывается: из нее выделяются цифры, которые выводятся на консоль. То есть тип phoneWriter осуществляет запись потока байт на консоль.
   </p>
   <p>
    В качестве результата метод возвращает длину среза и значение nil.
   </p>
   <p>
    Для имитации потока байт определяются два среза байт на основе строк, которые передаются в метод Write.
   </p>
   <p>
    На основе выше рассмотренных интерфейсов Writer и Reader основана вся система ввода-вывода в Go, и впоследствии мы более детально рассмотрим их примение при работе с файлами и сетевыми потоками.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Создание и открытие файлов
   </h2>
   <div class="date">
    Последнее обновление: 15.01.2018
   </div>
   <p>
    Для работы с файлами мы можем использовать функциональность пакета
    <a href="https://golang.org/pkg/os/" rel="nofollow">
     os
    </a>
    . 
Все файлы в Go представлены типом
    <span class="b">
     os.File
    </span>
    . Этот тип реализует ряд интерфейсов, например, io.Reader и io.Writer, 
которые позволяют читать содержимое файла и сохранять данные в файл.
   </p>
   <p>
    С помощью функции
    <span class="b">
     os.Create()
    </span>
    можно создать файл по определенному пути. Путь к файлу передается в качестве параметра. 
Если подобный файл уже существует, то он перезаписывается:
   </p>
   <pre class="brush:go;">file, err := os.Create("hello.txt")</pre>
   <p>
    Функция возвращает объект os.File для работы с файлом и информацию об ошибке, которая может возникнуть при создании файла.
   </p>
   <p>
    Ранее созданный файл можно открыть с помощью функции
    <span class="b">
     os.Open()
    </span>
    :
   </p>
   <pre class="brush:go;">file, err := os.Open("hello.txt")</pre>
   <p>
    Эта функция также возвращает объект os.File для работы с файлом и информацию об ошибке, которая может возникнуть при открытии файла.
   </p>
   <p>
    Также в нашем распоряжении есть функция
    <span class="b">
     os.OpenFile()
    </span>
    , которая открывает файл, а если файла нет, то создает его. Она принимает три параметра:
   </p>
   <ul>
    <li>
     <p>
      путь к файлу
     </p>
    </li>
    <li>
     <p>
      режим открытия файла (для чтения, для записи и т.д.)
     </p>
    </li>
    <li>
     <p>
      разрешения для доступа к файлу
     </p>
    </li>
   </ul>
   <p>
    Например:
   </p>
   <pre class="brush:go;">// открытие файла для чтения
f1, err := os.OpenFile("sometext.txt", os.O_RDONLY, 0666) 
// открытие файла для записи
f2, err := os.OpenFile("common.txt", os.O_WRONLY, 0666)</pre>
   <p>
    После окончания работы с файлом его следует закрыть с помощью метода
    <span class="b">
     Close()
     .
    </span>
   </p>
   <pre class="brush:go;">package main
import (
"fmt"
"os"
)

func main() { 
	file, err := os.Create("hello.txt")		// создаем файл
	if err != nil{							// если возникла ошибка
		fmt.Println("Unable to create file:", err) 
        os.Exit(1) 							// выходим из программы
	}
	defer file.Close() 						// закрываем файл
	fmt.Println(file.Name())				// hello.txt
}</pre>
   <p>
    С помощью функции
    <span class="b">
     os.Exit()
    </span>
    можно выйти из программы. А метод
    <code>
     Name()
    </code>
    , определенный для типа os.File, позволяет получить имя файла.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Чтение и запись файлов
   </h2>
   <div class="date">
    Последнее обновление: 15.01.2018
   </div>
   <h3>
    Запись в файл
   </h3>
   <p>
    Для записи текстовой информации в файл можно применять метод
    <span class="b">
     WriteString()
    </span>
    объекта os.File, который заносит в файл строку:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"os"
)

func main() {
	text := "Hello Gold!"
	file, err := os.Create("hello.txt")
	
	if err != nil{
		fmt.Println("Unable to create file:", err) 
        os.Exit(1) 
	}
	defer file.Close() 
	file.WriteString(text)
	
	fmt.Println("Done.")
}</pre>
   <p>
    В данном случае создается файл hello.txt, в который записывается строка "Hello Gold!".
   </p>
   <p>
    Для записи нетекстовой бинарной информации в виде набора байт применяется метод
    <span class="b">
     Write()
    </span>
    (реализация интерфейса io.Writer):
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"os"
)

func main() {
	data := []byte("Hello Bold!")
	file, err := os.Create("hello.bin")
	if err != nil{
		fmt.Println("Unable to create file:", err) 
        os.Exit(1) 
	}
	defer file.Close() 
	file.Write(data)
	
	fmt.Println("Done.")
}</pre>
   <h3>
    Чтение из файла
   </h3>
   <p>
    Поскольку тип
    <code>
     io.File
    </code>
    реализует интерфейс
    <code>
     io.Reader
    </code>
    , то для чтения из файла мы можем использовать метод
    <span class="b">
     Read()
    </span>
    . 
Этот метод позволяет получить содержимое файла в виде набора байт:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"os"
	"io"
)

func main() {
	file, err := os.Open("hello.txt")
	if err != nil{
		fmt.Println(err) 
        os.Exit(1) 
	}
	defer file.Close() 
	
	data := make([]byte, 64)
	
	for{
		n, err := file.Read(data)
		if err == io.EOF{	// если конец файла
			break			// выходим из цикла
		}
		fmt.Print(string(data[:n]))
	}
}</pre>
   <p>
    Для считывания данных определяется срез из 64 байтов. В бесконечном цикле содержимое файла считывается в срез, а когда будет достигнут конец файла, 
то есть мы получим ошибку io.EOF, то произойдет выход из цикла. Ну и поскольку данные представляют срез байтов, хотя файл hello.txt хранит текстовую информацию, 
то для вывода текста на консоль преобразуем срез байтов в строку:
    <code>
     string(data[:n])
    </code>
    .
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Стандартные потоки ввода-вывода и io.Copy
   </h2>
   <div class="date">
    Последнее обновление: 15.01.2018
   </div>
   <p>
    Пакет
    <span class="b">
     os
    </span>
    определяет три переменных:
    <span class="b">
     os.Stdin
    </span>
    ,
    <span class="b">
     os.Stdout
    </span>
    и
    <span class="b">
     os.Stderr
    </span>
    , 
которые представляют стандартные потоки ввода, вывода и вывода ошибок соответственно. Так, стандартный поток вывода
    <span class="b">
     os.Stdout
    </span>
    представляет 
вывод информации на консоль.
   </p>
   <p>
    Например, мы можем использовать функцию
    <span class="b">
     io.Copy()
    </span>
    для копирования данных из одного потока в другой:
   </p>
   <pre class="brush:go;">n, err = io.Copy(io.Writer, io.Reader)</pre>
   <p>
    Эта функция упрощает копирование данных из объекта
    <code>
     io.Reader
    </code>
    в объект
    <code>
     io.Writer
    </code>
    . В качестве результата функция возвращает количество 
скопированных файлов и информацию об ошибке.
   </p>
   <p>
    И при выводе из файла текстовой информации на консоль гораздо проще передать данные из файлового потока в 
os.Stdout, через выводить данные отдельными порциями:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"os"
	"io"
)

func main() {
	file, err := os.Open("hello.txt")
	if err != nil{
		fmt.Println(err) 
        os.Exit(1) 
	}
	defer file.Close() 
	
	io.Copy(os.Stdout, file)
}</pre>
   <p>
    В качестве io.Reader можно использовать свои кастомные объекты, которые реализуют данный интерфейс. Например:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"io"
	"os"
)

type phoneReader string

func (p phoneReader) Read(bs []byte) (int, error){
	count := 0
	for i := 0; i &lt; len(p); i++{
		if(p[i] &gt;= '0' &amp;&amp; p[i] &lt;= '9'){
			bs[count] = p[i]
			count++
		}
	}
	return count, io.EOF
}

func main() { 
	phone1 := phoneReader("+1(234)567 90-10")
	io.Copy(os.Stdout, phone1)
	fmt.Println()
}</pre>
   <p>
    В данном случае в качестве интерфейса io.Reader передается объект phoneReader, который считывает цифровые символы из номера телефона.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Форматированный вывод
   </h2>
   <div class="date">
    Последнее обновление: 15.01.2018
   </div>
   <p>
    Ряд возможностей по чтению и записи файлов предоставляет пакет
    <a href="https://golang.org/pkg/fmt" rel="nofollow">
     fmt
    </a>
    . 
Этот пакет предоставляет ряд функций для записи данных в произвольный объект, который реализует интерфейс
    <code>
     io.Writer
    </code>
    :
    <span class="b">
     fmt.Fprint()
    </span>
    ,
    <span class="b">
     fmt.Fprintln()
    </span>
    и
    <span class="b">
     fmt.Fprintf()
    </span>
    .
   </p>
   <h3>
    Функции Fprint и Fprintln
   </h3>
   <p>
    Функции Fprint и Fprintln имеют примерно одинаковое определение:
   </p>
   <pre class="brush:go;">func Fprint(w io.Writer, a ...interface{}) (n int, err error)
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)</pre>
   <p>
    Первым параметром передается объект, который реализует интерфейс io.Writer. А второй параметр представляет набор объектов, которые записываются в поток. Обе функции 
возвращают количество записанных байтов и информацию об ошибке. Отличием функции Fprintln является то, что она добавляет при выводе перевод строки, то есть фактически записывает строку. Например:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"os"
)

func main() {
	file, err := os.Create("confeve.txt")
	if err != nil{
		fmt.Println(err) 
        os.Exit(1) 
	}
	defer file.Close() 
	fmt.Fprint(file, "Сегодня ")
	fmt.Fprintln(file, "хорошая погода")
}</pre>
   <p>
    В данном случае обе функции записывают некоторый текст в файл confeve.txt, который будет создан в той же папке, где расположен выполняемый скрипт.
   </p>
   <h3>
    Форматирование и Fprintf
   </h3>
   <p>
    Функция Fprintf упрощает запись сложных по структуре данных:
   </p>
   <pre class="brush:go;">func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)</pre>
   <p>
    Первым параметром также идет объект io.Writer. Второй параметр представляет строку форматирования, которая указывает, как данные будут форматироваться при записи. 
И третий параметр - набор значений, которые передаются в строку форматирования и записываются в поток вывода.
   </p>
   <p>
    Строка форматирования представляет набор спецификаторов. Каждый спецификатор представляет набор символов, которые интерпретируются определенным образом и предваряются 
знаком процента %. Каждый спецификатор представляет определенный тип данных:
   </p>
   <ul>
    <li>
     <p>
      <code>
       %t
      </code>
      : для вывода значений типа boolean (true или false)
     </p>
    </li>
    <li>
     <p>
      <code>
       %b
      </code>
      : для вывода целых чисел в двоичной системе
     </p>
    </li>
    <li>
     <p>
      <code>
       %c
      </code>
      : для вывода символов, представленных числовым кодом
     </p>
    </li>
    <li>
     <p>
      <code>
       %d
      </code>
      : для вывода целых чисел в десятичной системе
     </p>
    </li>
    <li>
     <p>
      <code>
       %o
      </code>
      : для вывода целых чисел в восьмеричной системе
     </p>
    </li>
    <li>
     <p>
      <code>
       %q
      </code>
      : для вывода символов в одинарных кавычках
     </p>
    </li>
    <li>
     <p>
      <code>
       %x
      </code>
      : для вывода целых чисел в шестнадцатиричной системе, буквенные символы числа имеют нижний регистр a-f
     </p>
    </li>
    <li>
     <p>
      <code>
       %X
      </code>
      : для вывода целых чисел в шестнадцатиричной системе, буквенные символы числа имеют верхний регистр A-F
     </p>
    </li>
    <li>
     <p>
      <code>
       %U
      </code>
      : для вывода символов в формате кодов Unicode, например, U+1234
     </p>
    </li>
    <li>
     <p>
      <code>
       %e
      </code>
      : для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456e+78
     </p>
    </li>
    <li>
     <p>
      <code>
       %E
      </code>
      : для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456E+78
     </p>
    </li>
    <li>
     <p>
      <code>
       %f
      </code>
      : для вывода чисел с плавающей точкой, например, 123.456
     </p>
    </li>
    <li>
     <p>
      <code>
       %F
      </code>
      : то же самое, что и %f
     </p>
    </li>
    <li>
     <p>
      <code>
       %g
      </code>
      : для длинных чисел с плаващей точкой используется %e, для других - %f
     </p>
    </li>
    <li>
     <p>
      <code>
       %G
      </code>
      : для длинных чисел с плаващей точкой используется %E, для других - %F
     </p>
    </li>
    <li>
     <p>
      <code>
       %s
      </code>
      : для вывода строки
     </p>
    </li>
    <li>
     <p>
      <code>
       %p
      </code>
      : для вывода значения указателя - адреса в шестнадцатеричном представлении
     </p>
    </li>
   </ul>
   <p>
    Также можно применять универсальный спецификатор
    <code>
     %v
    </code>
    , который для типа boolean аналогичен
    <code>
     %t
    </code>
    , для целочисленных типов -
    <code>
     %d
    </code>
    , для чисел с плавающей точкой -
    <code>
     %g
    </code>
    , для строк -
    <code>
     %s
    </code>
    .
   </p>
   <p>
    К спецификаторам можно добавлять различные флаги, которые влияют на форматирование значений. Например, число перед спецификатором указывает, какую минимальную длину в символах будет занимать выводимое 
значение. Например,
    <code>
     %9f
    </code>
    - число с плаващей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.
   </p>
   <p>
    Для чисел с плавающей точкой можно указать точность или количество символов в дробной части. Для этого количество символов указывается после точки:
    <code>
     %.2f
    </code>
    - 
две цифры в дробной части после точки. Например, варианты форматирования чисел с плавающей точкой:
   </p>
   <ul style="list-style-type:none;">
    <li>
     <p>
      <code>
       %f
      </code>
      : точность и ширина значения по умолчанию
     </p>
    </li>
    <li>
     <p>
      <code>
       %9f
      </code>
      : ширина - 9 символов и точность по умолчанию
     </p>
    </li>
    <li>
     <p>
      <code>
       %.2f
      </code>
      : ширина по умолчанию и точность - 2 символа
     </p>
    </li>
    <li>
     <p>
      <code>
       %9.2f
      </code>
      : ширина - 9 и точность - 2
     </p>
    </li>
    <li>
     <p>
      <code>
       %9.f
      </code>
      : ширина - 9 и точность - 0
     </p>
    </li>
   </ul>
   <p>
    Также из флагов следует отметить дефис -, который дополняет значение пробелами не справа, как по умолчанию, а слева.
   </p>
   <p>
    Применим функцию Fprintf для вывода в файл:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"os"
)
type person struct { 
   name string 
   age int32 
   weight float64 
}
func main() {
	tom := person {
		name:"Tom",
		age: 24,
		weight: 68.5,
	}
	file, err := os.Create("person.dat")
	if err != nil{
		fmt.Println(err) 
        os.Exit(1) 
	}
	defer file.Close() 
	fmt.Fprintf( file, 
               "%-10s %-10d %-10.3f\n", 
               tom.name, tom.age, tom.weight)
}</pre>
   <p>
    Функция
    <code>
     Fprintf()
    </code>
    в качестве первого параметра также принимает файл, а в качестве второго параметра - строку форматирования, 
которая определяет, как данные будут форматироваться. После строки форматирования перечисляются значения, которые вставляются вместо спецификаторов. При этом значения передаются на место спецификаторов по позиции. 
Например, первое значение передается вместо первого спецификатора, второе значение - вместо второго спецификатора и так далее. При этом значения должны 
соответствовать спецификаторам по типу: на место спецификатора %s должна передаваться строка, на место %d - целое число и т.д.
   </p>
   <p>
    Таким образом, в примере выше будет создан в одной папке со скриптом файл person.dat, в который будет записаны данные объекта person.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Вывод на консоль
   </h2>
   <div class="date">
    Последнее обновление: 15.01.2018
   </div>
   <p>
    Стандартным потоком вывода в Go является объект
    <span class="b">
     os.Stdout
    </span>
    , который фактически представляет консоль. Например, мы могли бы 
вывести в этот поток данные следующим образом:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"os"
)

func main() {
	fmt.Fprintln(os.Stdout, "hello cold")
}</pre>
   <p>
    Здесь используется рассмотренная в прошлой теме функция
    <code>
     Fprintln()
    </code>
    , которая выводит в поток вывода набор значений. То есть фактически 
в данном случае идет запись или вывод на консоль.
   </p>
   <p>
    Однако поскольку запись в стандартный поток os.Stdout - довольно распространенная задача, то вместо функций
    <code>
     Fprint/Fprintln/Fprintf
    </code>
    применяются их 
двойники:
    <span class="b">
     Println()
    </span>
    ,
    <span class="b">
     Print()
    </span>
    и
    <span class="b">
     Printf()
    </span>
    соответственно, которые по умолчанию 
выводят данные в os.Stdout:
   </p>
   <pre class="brush:go;">package main
import "fmt"

type person struct { 
   name string 
   age int32 
   weight float64 
}
func main() {
	tom := person {
		name:"Tom",
		age: 24,
		weight: 68.5,
	}
	fmt.Printf("%-10s %-10d %-10.3f\n", 
               tom.name, tom.age, tom.weight)
	fmt.Print("Hello ")
	fmt.Println("cold!")
}</pre>
  </div>
  <div class="item center menC">
   <h2>
    Форматируемый ввод
   </h2>
   <div class="date">
    Последнее обновление: 15.01.2018
   </div>
   <p>
    Пакет
    <span class="b">
     fmt
    </span>
    чтение из объекта, который реализует интерфейс
    <span class="b">
     io.Reader
    </span>
    . 
Для этого применяются следующие функции:
    <span class="b">
     Fscan()
    </span>
    ,
    <span class="b">
     Fscanln()
    </span>
    и
    <span class="b">
     Fscanf()
    </span>
    .
   </p>
   <h3>
    Функции Fscan и Fscanln
   </h3>
   <p>
    Через параметры функций Fscan и Fscanln можно получить вводимые значения:
   </p>
   <pre class="brush:go;">func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)</pre>
   <p>
    В качестве первого параметра передается объект io.Reader, из которого надо считывать данные, а второй параметр представляет объекты, в которые считываются данные. 
В качестве результата обе функции возвращают количество считанных байт и информацию об ошибке. Например:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"os"
)

type person struct { 
   name string 
   age int32 
   weight float64 
}
func main() {
	filename := "hello2.txt"
	writeData(filename)
	readData(filename)
}

func writeData(filename string){
	// начальные данные
	var name string = "Tom"
	var age int	= 24
	
	file, err := os.Create(filename)
	if err != nil { 
		fmt.Println(err)
		os.Exit(1)
	}
	defer file.Close() 
	
	fmt.Fprintln(file, name)
	fmt.Fprintln(file, age)
}
func readData(filename string){
	
	var name string
	var age int
	
	file, err := os.Open(filename)
	if err != nil{
		fmt.Println(err) 
        os.Exit(1)
	}
	defer file.Close()
	
	fmt.Fscanln(file, &amp;name) 
	fmt.Fscanln(file, &amp;age) 
	fmt.Println(name, age)
}</pre>
   <p>
    В данном случае вначале записываем две переменных в файл с помощью fmt.Fprintln, а затем считываем записанные значения с помощью fmt.Fscanln.
   </p>
   <h3>
    Fscanf
   </h3>
   <p>
    Функция
    <span class="b">
     fmt.Fscanf()
    </span>
    считывает данные с применением форматирования:
   </p>
   <pre class="brush:go;">func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)</pre>
   <p>
    Первый параметр функции представляет объект io.Reader. Второй параметр - строка форматирования, которая содержит спецификаторы и определяет последовательность 
считывания данных. Третий параметр - набор объектов, в которые надо считать данные. Например:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"os"
)

type person struct { 
   name string 
   age int32 
   weight float64 
}
func main() {
	filename := "person.dat"
	writeData(filename)
	readData(filename)
}

func writeData(filename string){
	// начальные данные
	tom := person { name:"Tom", age: 24, weight: 68.5 }
	
	file, err := os.Create(filename)
	if err != nil { 
		fmt.Println(err)
		os.Exit(1)
	}
	defer file.Close() 
	
	// сохраняем данные в файл
	fmt.Fprintf(file, "%s %d %.2f\n", tom.name, tom.age, tom.weight)
}
func readData(filename string){
	
	// переменные для считывания данных
	var name string
	var age int 
	var weight float64
	
	file, err := os.Open(filename)
	if err != nil{
		fmt.Println(err) 
        os.Exit(1)
	}
	defer file.Close()
	
	// считывание данных из файла
	_, err = fmt.Fscanf(file, "%s %d %f\n", &amp;name, &amp;age, &amp;weight) 
	if err != nil{
		fmt.Println(err) 
        os.Exit(1)
	}
	fmt.Printf("%-8s %-8d %-8.2f\n", name, age, weight)
}</pre>
   <p>
    Здесь вначале данные структуры person записываются в файл, а затем считываются из него в три переменных. При записи данных файл мы знаем его структуру. 
Поэтому мы можем взять строку форматирования с той же последовательностью спецификаторов и выполнить обратное действие - считать данные. При считывание в объекты в функцию 
передаются их адреса:
   </p>
   <pre class="brush:go;">fmt.Fscanf(file, "%s %d %f\n", &amp;name, &amp;age, &amp;weight)</pre>
   <p>
    При определении строки форматирования и передаче объктов для считывания действуют те же правила, что и при записи с помощью fmt.Fprintf. Так, первый спецификатор 
связан с первым объектом, второй спецификатор - со вторым объектом и так далее. И также спецификаторы должны соответствовать объетам по типу.
   </p>
   <p>
    В итоге при выполнении этой программы на консоль будет выведено:
   </p>
   <div class="console">
    <pre class="consoletext">Tom	24	68.50</pre>
   </div>
   <p>
    При этом объекты, в которые производится считывание, необязательно должны представлять переменные примитивных типов. Например, это может быть и структура:
   </p>
   <pre class="brush:go;">func readData(filename string){
	
	// переменная для считывания данных
	tom := person{}
	
	file, err := os.Open(filename)
	if err != nil{
		fmt.Println(err) 
        os.Exit(1)
	}
	defer file.Close()
	
	// считывание данных из файла
	_, err = fmt.Fscanf(file, "%s %d %f\n", &amp;tom.name, &amp;tom.age, &amp;tom.weight) 
	
	if err != nil{
		fmt.Println(err) 
        os.Exit(1)
	}
	fmt.Printf("%-8s %-8d %-8.2f\n", tom.name, tom.age, tom.weight)
}</pre>
   <p>
    Рассмотрим более сложный пример, когда файл содержит набор данных структур person:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"os"
	"io"
)

type person struct { 
   name string 
   age int32 
   weight float64 
}
func main() {
	filename := "people.dat"
	writeData(filename)
	readData(filename)
}

func writeData(filename string){
	// начальные данные
	var people = []person{
		{ "Tom", 24, 68.5 },
		{ "Bob", 25, 64.2 },
		{ "Sam", 27, 73.6 },
	}
	
	file, err := os.Create(filename)
	if err != nil { 
		fmt.Println(err)
		os.Exit(1)
	}
	defer file.Close() 
	
	for _, p := range people{
		fmt.Fprintf(file, "%s %d %.2f\n", p.name, p.age, p.weight)
	}
}
func readData(filename string){
	
	var name string
	var age int 
	var weight float64
	
	file, err := os.Open(filename)
	if err != nil{
		fmt.Println(err) 
        os.Exit(1)
	}
	defer file.Close()
	
	for{
		_, err = fmt.Fscanf(file, "%s %d %f\n", &amp;name, &amp;age, &amp;weight) 
		if err != nil{
			if err == io.EOF{
				break
			} else{
				fmt.Println(err) 
				os.Exit(1)
			}
		}
		fmt.Printf("%-8s %-8d %-8.2f\n", name, age, weight)
	}
}</pre>
   <p>
    Сначала функция writeData записывает в файл набор объектов person. А затем в функции readData из файла считываются данные в бесконечном цикле. Когда 
файл закончится, функция Fscanf возвратит ошибку io.EOF.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Чтение с консоли
   </h2>
   <div class="date">
    Последнее обновление: 15.01.2018
   </div>
   <p>
    В Go имеется объект
    <span class="b">
     os.Stdin
    </span>
    , который реализует интерфейс io.Reader и позволяет считывать данные с консоли. Например, мы можем использовать 
функцию
    <code>
     fmt.Fscan()
    </code>
    для считывания с консоли с помощью os.Stdin:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"os"
)

func main() {
	var name string
	var age int
	fmt.Print("Введите имя: ")
	fmt.Fscan(os.Stdin, &amp;name) 
	
	fmt.Print("Введите возраст: ")
	fmt.Fscan(os.Stdin, &amp;age)
	
	fmt.Println(name, age)
}</pre>
   <p>
    При запуске программы мы сможем вводить данные с консоли, и они перейдут в переменные name и age:
   </p>
   <div class="console">
    <pre class="consoletext">Введите имя: Tom
Введите возраст: 24
Tom 24</pre>
   </div>
   <p>
    Однако также для получения ввода с консоли мы можем использовать встроенные функции
    <span class="b">
     fmt.Scan()
    </span>
    ,
    <span class="b">
     fmt.Scanln()
    </span>
    и
    <span class="b">
     fmt.Scanf()
    </span>
    , которые аналогичны соответственно функциям
    <code>
     fmt.Fscan()
    </code>
    ,
    <code>
     fmt.Scanln()
    </code>
    и
    <code>
     fmt.Scanf()
    </code>
    :
   </p>
   <pre class="brush:go;">func Scan(a ...interface{}) (n int, err error)
func Scanf(format string, a ...interface{}) (n int, err error)
func Scanln(a ...interface{}) (n int, err error)</pre>
   <p>
    Все эти функции уже по умолчанию считывают данные с потока os.Stdin:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"os"
)

func main() {
	var name string
	var age int
	fmt.Print("Введите имя: ")
	fmt.Scan(&amp;name) 
	fmt.Print("Введите возраст: ")
	fmt.Scan(&amp;age)
	
	fmt.Println(name, age)
}</pre>
   <p>
    или так
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"os"
)

func main() {
	var name string
	var age int
	fmt.Print("Введите имя и возраст: ")
	fmt.Scan(&amp;name, &amp;age)
	fmt.Println(name, age)
	
	// альтернативный вариант
	//fmt.Println("Введите имя и возраст:")
	//fmt.Scanf("%s %d", &amp;name, &amp;age)
	//fmt.Println(name, age)
}</pre>
   <p>
    В случае если вводятся сразу несколько значений, то разделителем между ними является пробел. Хотя теоретически строка может включать внутренние пробелы, тем не менее 
данные функции считывают значение строки и других типов данных до пробела:
   </p>
   <div class="console">
    <pre class="consoletext">Введите имя и возраст: Tom 34
Tom 34</pre>
   </div>
  </div>
  <div class="item center menC">
   <h2>
    Буферизированный ввод-вывод
   </h2>
   <div class="date">
    Последнее обновление: 16.01.2018
   </div>
   <p>
    Большиство встроенных операций ввода-вывода не используют буфер. Это может иметь отрицательный эффект для производительности приложения. Для 
буферизации потоков чтения и записи в Go опредеелены ряд возможностей, которые сосредоточены в пакете
    <span class="b">
     bufio
    </span>
    .
   </p>
   <h3>
    Запись через буфер
   </h3>
   <p>
    Для записи в источник данных через буфер в пакете bufio определен тип
    <span class="b">
     Writer
    </span>
    . Чтобы записать данные, можно воспользоваться 
одним из его методов:
   </p>
   <pre class="brush:go;">func (b *Writer) Write(p []byte) (nn int, err error)
func (b *Writer) WriteByte(c byte) error
func (b *Writer) WriteRune(r rune) (size int, err error)
func (b *Writer) WriteString(s string) (int, error)</pre>
   <ul>
    <li>
     <p>
      <span class="b">
       Write()
      </span>
      : записывает срез байтов
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       WriteByte()
      </span>
      : записывает один байт
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       WriteRune()
      </span>
      : записывает один объект типа rune
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       WriteString()
      </span>
      : записывает строку
     </p>
    </li>
   </ul>
   <p>
    При выполнении этих методов данные вначале накапливаются в буфере, а чтобы сбросить их в источник данных, необходимо вызвать метод
    <span class="b">
     Flush()
    </span>
    .
    <p>
     Для создания потока вывода через буфер применяется функция
     <span class="b">
      bufio.NewWriter()
     </span>
     :
    </p>
    <pre class="brush:go;">func NewWriter(w io.Writer) *Writer</pre>
    <p>
     Она принимает объект io.Writer - это может быть любой объект, в который идет запись: os.Stdout, файл и т.д. В качестве результата возвращается объект bufio.Writer:
    </p>
    <pre class="brush:go;">package main
import (
	"fmt"
	"os"
	"bufio"
)
func main() { 
   rows := []string{ 
         "Hello Go!", 
         "Welcome to Golang", 
   } 
 
   file, err := os.Create("some.dat") 
   writer := bufio.NewWriter(file) 
   if err != nil { 
         fmt.Println(err) 
         os.Exit(1) 
   } 
   defer file.Close() 
 
   for _, row := range rows { 
         writer.WriteString(row) 	// запись строки
         writer.WriteString("\n") 	// перевод строки
   } 
   writer.Flush() 		// сбрасываем данные из буфера в файл
}</pre>
    <p>
     В данном случае в файл через буферизированный поток вывода записываются две строки.
    </p>
    <h3>
     Чтение через буфер
    </h3>
    <p>
     Для чтения из источника данных через буфер в пакете bufio определен тип
     <span class="b">
      Reader
     </span>
     . Для чтения данных можно 
воспользоваться одним из его методов:
    </p>
    <pre class="brush:go;">func (b *Reader) Read(p []byte) (n int, err error)
func (b *Reader) ReadByte() (byte, error)
func (b *Reader) ReadBytes(delim byte) ([]byte, error)
func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)
func (b *Reader) ReadRune() (r rune, size int, err error)
func (b *Reader) ReadSlice(delim byte) (line []byte, err error)
func (b *Reader) ReadString(delim byte) (string, error)</pre>
    <ul>
     <li>
      <p>
       <span class="b">
        Read(p []byte)
       </span>
       : считывает срез байтов и возвращает количество прочитанных байтов
      </p>
     </li>
     <li>
      <p>
       <span class="b">
        ReadByte()
       </span>
       : считывает один байт
      </p>
     </li>
     <li>
      <p>
       <span class="b">
        ReadBytes(delim byte)
       </span>
       : считывает срез байтов из потока, пока не встретится байт delim
      </p>
     </li>
     <li>
      <p>
       <span class="b">
        ReadLine()
       </span>
       : считывает строку в виде среза байт
      </p>
     </li>
     <li>
      <p>
       <span class="b">
        ReadRune()
       </span>
       : считывает один объект типа rune
      </p>
     </li>
     <li>
      <p>
       <span class="b">
        ReadSlice(delim byte)
       </span>
       : считывает срез байтов из потока, пока не встретится байт delim
      </p>
     </li>
     <li>
      <p>
       <span class="b">
        ReadString(delim byte)
       </span>
       : считывает строку, пока не встретится байт delim
      </p>
     </li>
    </ul>
    <p>
     Для создания потока ввода через буфер применяется функция
     <span class="b">
      bufio.NewReader()
     </span>
     :
    </p>
    <pre class="brush:go;">func NewReader(rd io.Reader) *Reader</pre>
    <p>
     Она принимает объект io.Reader - это может быть любой объект, с которого производится чтение: os.Stdin, файл и т.д. В качестве результата 
возвращается объект bufio.Reader:
    </p>
    <pre class="brush:go;">package main
import (
	"fmt"
	"os"
	"bufio"
	"io"
)
func main(){
	file, err := os.Open("some.data") 
	if err != nil { 
         fmt.Println("Unable to open file:", err) 
         return 
	} 
	defer file.Close() 
 
	reader := bufio.NewReader(file) 
	for { 
		line, err := reader.ReadString('\n') 
		if err != nil { 
			if err == io.EOF { 
				break 
			} else { 
				fmt.Println(err) 
				return 
			} 
		} 
		fmt.Print(line) 
	}
}</pre>
    <p>
     В данном случае идет считывания из ранее записанного файла. Для этого объект файла os.File передается в функцию bufio.NewReader, на основании которого создается 
объект bufio.Reader. Поскольку идет построчное считывание, то каждая строка считывается из потока, пока не будет обнаружен символ перевода строки \n.
    </p>
   </p>
  </div>
  <div class="item center menC">
   <h1>
    Сетевое программирование
   </h1>
   <div class="date">
    Последнее обновление: 23.01.2018
   </div>
   <p>
    Одной из ключевых возможностей языка Go является возможность работы с сетевыми сервисами: отправлять запросы к ресурсам в сети и, наоборот, обрабатывать входящие запросы. 
Основной функционал по работе с сетью представлен пакетом
    <a href="https://golang.org/pkg/net" rel="nofollow">
     net
    </a>
    . 
Этот пакет предоставляет различные низкоуровневые сетевые примитивы, через которые идет взамодействие по сети.
   </p>
   <h2>
    Отправка запросов
   </h2>
   <p>
    Для отправки запросов к ресурсам в сети применяется функция
    <span class="b">
     net.Dial()
    </span>
    :
   </p>
   <pre class="brush:go;">func Dial(network, address string) (Conn, error)</pre>
   <p>
    Эта функция принимает два параметра: network - тип протокола и address - адрес ресурса.
   </p>
   <p>
    Есть следующие типы протоколов:
   </p>
   <ul>
    <li>
     <p>
      <code>
       tcp, tcp4, tcp6
      </code>
      : протокол TCP. tcp по умолчанию представляет tcp4, цифра в конце указывает, какой тип адресов будет использоваться: IPv4 или IPv6
     </p>
    </li>
    <li>
     <p>
      <code>
       udp, udp4, udp6
      </code>
      : протокол UDP. udp по умолчанию представляет udp4
     </p>
    </li>
    <li>
     <p>
      <code>
       ip, ip4, ip6
      </code>
      : протокол IP. ip по умолчанию представляет ip4
     </p>
    </li>
    <li>
     <p>
      <code>
       unix, unixgram, unixpacket
      </code>
      : сокеты Unix
     </p>
    </li>
   </ul>
   <p>
    Второй параметр представляет сетевой адрес ресурса (для адресов в сети интернет это домен). Это может быть числовой сетевой адрес, например,
    <code>
     "127.0.0.1"
    </code>
    . Он может включать указание порта, например,
    <code>
     "127.0.0.1:80"
    </code>
    . Это также может быть адрес в формате IPv6, например,
    <code>
     "::1"
    </code>
    или
    <code>
     "[2516:b7f0:3421:b16::71]:80"
    </code>
    .
   </p>
   <p>
    Функция возращает объект, который реализует интерфейс
    <span class="b">
     net.Conn
    </span>
    . Этот интерфейс, в свою очередь, применяет интерфейсы 
io.Reader и io.Writer, то есть может использоваться как поток для чтения и записи. Пакет net предоставляет базовые реализации этого интерфейса 
в виде типов
    <span class="b">
     IPConn
    </span>
    ,
    <span class="b">
     UDPConn
    </span>
    ,
    <span class="b">
     TCPConn
    </span>
    . В зависимости от используемого протокола возвращается соответствующий тип.
   </p>
   <p>
    Таким образом, используя данную функцию, мы можем отправлять запросы по протоколу TCP и UDP. Например:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"os"
	"net"
	"io"
)
func main() {
	httpRequest:="GET / HTTP/1.1\n" + 
		"Host: golang.org\n\n"
	conn, err := net.Dial("tcp", "golang.org:80") 
	if err != nil { 
		fmt.Println(err) 
		return 
	} 
	defer conn.Close() 
 
	if _, err = conn.Write([]byte(httpRequest)); err != nil { 
		fmt.Println(err) 
		return 
	}
 
	io.Copy(os.Stdout, conn) 
	fmt.Println("Done")
}</pre>
   <p>
    В данном случае мы фактически обращаемся к веб-ресурсу golang.ru. Так как
    <code>
     net.Conn
    </code>
    реализует интерфейсы
    <code>
     io.Reader
    </code>
    и
    <code>
     io.Writer
    </code>
    , то в данный объект можно записывать данные - фактически посылать по сети данные и можно считывать с него данные - 
получать данные из сети. Например,
    <code>
     conn.Write([]byte(httpRequest))
    </code>
    посылает данные, которые здесь представлены переменной httpRequest. Так как метод 
Write отправляет срез байтов, то любые данные надо преобразовать в срез байтов.
   </p>
   <p>
    Как и любой объект io.Reader, мы можем передать net.Conn в функцию io.Copy и считать полученные по сети данные, например, на консоль:
    <code>
     io.Copy(os.Stdout, conn)
    </code>
    .
   </p>
   <img alt="net.Dial и TCP, отправка запроса в Golang" src="https://metanit.com/go/tutorial/pics/9.1.png"/>
   <p>
    Стоит отметить, что в примере выше осуществляет запрос к сетевому ресурсу сети интернет по протоколу TCP. Однако для этой же цели куда более удобнее использовать возможности 
пакета net/http, который предназначен специально для протокола HTTP, который работает поверх TCP.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Сервер. Обработка подключений
   </h2>
   <div class="date">
    Последнее обновление: 16.01.2018
   </div>
   <p>
    Для прослушивания и приемы входящих запросов в пакете net определена функция
    <span class="b">
     net.Listen
    </span>
    :
   </p>
   <pre class="brush:go;">func Listen(network, laddr string) (net.Listener, error)</pre>
   <p>
    Функция принимает два параметра: network - протокол, по которому приложение будет получать запросы, и laddr представляет локальный адрес, по 
которому будет запускаться сервер. Протокол должен представлять одно из значений: "tcp", "tcp4", "tcp6", "unix", "unixpacket". Локальный адрес может содержать только номер порта, например, ":8080". В этом случае приложение будет обслуживать по всем.
   </p>
   <p>
    В случае успешного выполнения функция возвращает объект интерфейса
    <span class="b">
     net.Listener
    </span>
    , который представляет функционал для приема входящих подключений. 
В зависимости от типа используемого протокола возвращаемый объект Listener может представлять тип
    <code>
     net.TCPListener
    </code>
    или
    <code>
     net.UnixListener
    </code>
    (оба этих типа реализуют интерфейс net.Listener).
   </p>
   <p>
    Основные методы, которые представляет net.Listener:
    <span class="b">
     Accept()
    </span>
    (принимает входящее подключение) и
    <span class="b">
     Close()
    </span>
    (закрывает подключение).
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"net"
)
func main() { 
	message := "Hello, I am a server"	// отправляемое сообщение
	listener, err := net.Listen("tcp", ":4545") 
	
	if err != nil {
		fmt.Println(err) 
		return 
	} 
	defer listener.Close() 
	fmt.Println("Server is listening...")
	for { 
		conn, err := listener.Accept() 
		if err != nil { 
			fmt.Println(err) 
			return 
		} 
		conn.Write([]byte(message)) 
		conn.Close() 
	} 
}</pre>
   <p>
    Вначале в функции
    <code>
     net.Listen("tcp", ":4545")
    </code>
    устанавливается 4545 порт для прослушивания подключений по протоколу TCP. После вызова этой функции 
сервер запущен и готов принимать подключения. Затем в бесконечном цикле for получаем входящие подключения с помощью вызова
    <code>
     listener.Accept()
    </code>
    . Этот метод возвращает объект net.Conn, который представляет 
подключенного клиента. Затем мы можем каким-нибудь образом обработать это подключение. Например, с помощью метода Write отправить ему сообщение. Поскольку данный метод 
принимает срез байтов, то любые сообщения надо транслировать в срез байтов:
    <code>
     conn.Write([]byte(message))
    </code>
   </p>
   <p>
    Для тестирования сервера определим еще одну программу - клиент:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"os"
	"net"
	"io"
)
func main() {

	conn, err := net.Dial("tcp", "127.0.0.1:4545") 
	if err != nil { 
		fmt.Println(err) 
		return 
	} 
	defer conn.Close() 
 
	io.Copy(os.Stdout, conn) 
	fmt.Println("\nDone")
}</pre>
   <p>
    Поскольку сервер будет запущен на локальном компьтере на порте 4545, то клиент подлючается к этому адресу:
    <code>
     net.Dial("tcp", "127.0.0.1:4545")
    </code>
   </p>
   <p>
    После этого к серверу будет отправляться запрос, и с помощью вызова
    <code>
     io.Copy(os.Stdout, conn)
    </code>
    выводим полученный ответ на консоль.
   </p>
   <p>
    Вначале запустим сервер. На Windows может отобразиться окно с предложением разрешить доступ:
   </p>
   <img alt="Запуск сервера на Go" src="https://metanit.com/go/tutorial/pics/9.2.png"/>
   <p>
    И после этого будет запущен сервер:
   </p>
   <img alt="Запуск сервера TCP на Golang" src="https://metanit.com/go/tutorial/pics/9.3.png"/>
   <p>
    Затем запустим клиент:
   </p>
   <img alt="Подключение клиента к серверу TCP на Go" src="https://metanit.com/go/tutorial/pics/9.4.png"/>
   <p>
    После запуска клиент подключится к серверу и получит от него сообщение.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Взаимодействие клиента и сервера
   </h2>
   <div class="date">
    Последнее обновление: 18.01.2018
   </div>
   <p>
    В прошлой теме было рассмотрено создание простейшего сервера TCP, к которому подключается клиент, и этому клиенту отправляется некоторое сообщение. 
Теперь рассмотрим, как клиент может посылать сообщения и получать ответ.
   </p>
   <p>
    Для начала определим следующий сервер:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"net"
)
var dict = map[string]string{ 
	"red": "красный",
	"green": "зеленый",
	"blue": "синий",
	"yellow": "желтый",
}
	
func main() {
	listener, err := net.Listen("tcp", ":4545") 
	
	if err != nil {
		fmt.Println(err) 
		return 
	} 
	defer listener.Close() 
	fmt.Println("Server is listening...")
	for { 
		conn, err := listener.Accept() 
		if err != nil { 
			fmt.Println(err) 
			conn.Close() 
			continue
		} 
		go handleConnection(conn)  // запускаем горутину для обработки запроса
	} 
}
// обработка подключения
func handleConnection(conn net.Conn) { 
	defer conn.Close()
	for {
		// считываем полученные в запросе данные
		input := make([]byte, (1024 * 4)) 
		n, err := conn.Read(input) 
		if n == 0 || err != nil {
			fmt.Println("Read error:", err)
			break
		}	 
		source := string(input[0:n])
		// на основании полученных данных получаем из словаря перевод 
		target, ok := dict[source]
		if ok == false{				// если данные не найдены в словаре
			target = "undefined"
		}
		// выводим на консоль сервера диагностическую информацию
		fmt.Println(source, "-", target)
		// отправляем данные клиенту
		conn.Write([]byte(target))
	}
}</pre>
   <p>
    Сервер имитирует поведение программы для перевода слов. Для этого определен словарь dit, который содержит англоязычные слова и их перевод.
   </p>
   <p>
    В бесконечном цикле сервер принимает подключения. Однако вместо прямой обработки подключения сервер запускает горутину в виде функции handleConnection, в которой и обрабатывается 
подключение. Это позволит входящим клиентам не ждать, пока первый из них будет обработан. Таким образом, все входящие клиенты в определенной степени 
будут обрабатываться одновременно.
   </p>
   <p>
    В функции handleConnection получаем запрос от клиента. Для этого выделяем буфер достаточной длины в 4096 байт.
   </p>
   <pre class="brush:go;">input := make([]byte, (1024 * 4)) 
n, err := conn.Read(input)</pre>
   <p>
    В данном случае мы ожидаем, что запрос от клиента не превысит 
4096 байт, однако точный размер запроса и его максимальный размер не всегда бывают известны. В этом случае мы можем применять различные техники, в частности, 
в бесконечном цикле считывать данные запроса от клиента и только потом их обрабатывать. Но в данном случае мы разберем более простую ситуацию.
   </p>
   <p>
    Получив запрос, преобразовав его строку, получаем значение из словаря и отправляем его обратно клиенту:
   </p>
   <pre class="brush:go;">conn.Write([]byte(target))</pre>
   <p>
    Для взаимодействия с этми сервером определим следующий клиент:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"net"
)
func main() {

	conn, err := net.Dial("tcp", "127.0.0.1:4545") 
	if err != nil { 
		fmt.Println(err) 
		return 
	}
	defer conn.Close()
	for{
		var source string
		fmt.Print("Введите слово: ") 
		_, err := fmt.Scanln(&amp;source) 
		if err != nil { 
			fmt.Println("Некорректный ввод", err) 
			continue
		}
		// отправляем сообщение серверу
		if n, err := conn.Write([]byte(source));
		n == 0 || err != nil { 
			fmt.Println(err) 
			return 
		}
		// получем ответ
		fmt.Print("Перевод:")
		buff := make([]byte, 1024)
		n, err := conn.Read(buff)
		if err !=nil{ break}
		fmt.Print(string(buff[0:n]))
		fmt.Println()
	}
}</pre>
   <p>
    На клиенте в бесконечном цикле вводим слово для перевода и отправляем серверу сообщение:
   </p>
   <pre class="brush:go;">if n, err := conn.Write([]byte(source));</pre>
   <p>
    И затем получаем от сервера ответ и выводим его на консоль. Так как ответ от сервера может быть переменной длины, то для получения ответа в бесконечом цикле считываем 
данные с помощью метода Read:
   </p>
   <pre class="brush:go;">buff := make([]byte, 1024)
n, err := conn.Read(buff)
if err !=nil{ break}
fmt.Print(string(buff[0:n]))</pre>
   <p>
    Запустим сервер.
   </p>
   <img alt="Отправка данных из клиента на сервер TCP в языке Go" src="https://metanit.com/go/tutorial/pics/9.5.png"/>
   <p>
    Затем запустим программу клиента и введем какое-либо значение и сервер возвратит перевод слова:
   </p>
   <img alt="Отправка данных из клиента на сервер в Golang" src="https://metanit.com/go/tutorial/pics/9.6.png"/>
   <p>
    Для выхода из программ сервера и клиента необходимо нажать комбинацию клавиш Ctrl+C.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    Установка таймаута
   </h2>
   <div class="date">
    Последнее обновление: 18.01.2018
   </div>
   <p>
    При взаимодействии клиента и сервера мы можем устанавливать таймаут, по истечении которого соединение между сервером и клиентом при отсутствии взаимодействия будет разорвано. 
Для этого у типа
    <span class="b">
     net.Conn
    </span>
    определены следующие методы:
   </p>
   <ul>
    <li>
     <p>
      <span class="b">
       SetDeadline(t time.Time) error
      </span>
      : устанавливает таймаут на все операции ввода-вывода. Для установки времени применяется структура
      <span class="b">
       time.Time
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       SetReadDeadline(t time.Time) error
      </span>
      : устанавливает таймаут на операции ввода в поток
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       SetWriteDeadline(t time.Time) error
      </span>
      : устанавливает таймаут на операции вывода из потока
     </p>
    </li>
   </ul>
   <p>
    В каком случае они могут пригодиться? В прошлой теме было рассмотрено взаимодействие сервера и клиента. Для чтения данных от клиента сервер использовал буфер фиксированного 
размера:
   </p>
   <pre class="brush:go;">input := make([]byte, (1024 * 4)) 
n, err := conn.Read(input)</pre>
   <p>
    Однако в ряде ситуаций это не лучший способ, особенно когда размер передаваемых данных превышает размер буфера. Мы можем точно не знать, сколько данных возвратит нам сервер. 
Поэтому определим следующий код клиента:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"net"
	"time"
)
func main() {

	conn, err := net.Dial("tcp", "127.0.0.1:4545") 
	if err != nil { 
		fmt.Println(err) 
		return 
	}
	defer conn.Close()
	for{
		var source string
		fmt.Print("Введите слово: ") 
		_, err := fmt.Scanln(&amp;source) 
		if err != nil { 
			fmt.Println("Некорректный ввод", err) 
			continue
		}
		// отправляем сообщение серверу
		if n, err := conn.Write([]byte(source));
		n == 0 || err != nil { 
			fmt.Println(err) 
			return 
		}
		// получем ответ
		fmt.Print("Перевод:")
		conn.SetReadDeadline(time.Now().Add(time.Second * 5))
		for{
			buff := make([]byte, 1024)
			n, err := conn.Read(buff)
			if err !=nil{ break}
			fmt.Print(string(buff[0:n]))
			conn.SetReadDeadline(time.Now().Add(time.Millisecond * 700))
		}
		fmt.Println()
	}
}</pre>
   <p>
    Теперь получение данных выделено в отдельный цикл for:
   </p>
   <pre class="brush:go;">for{
	buff := make([]byte, 1024)
	n, err := conn.Read(buff)
	if err !=nil{ break}
	fmt.Print(string(buff[0:n]))
	conn.SetReadDeadline(time.Now().Add(time.Millisecond * 700))
}</pre>
   <p>
    Поэтому даже если сервер передал больше 1024 байт, все они все равно будут обработаны. Но кроме того, здесь также устанавливается таймаут на чтение данных. 
Перед самим циклом устанавливается таймаут в 5 секунд:
   </p>
   <pre class="brush:go;">conn.SetReadDeadline(time.Now().Add(time.Second * 5))</pre>
   <p>
    Это значит, что клиент может ожидать данные на чтение от сервера в течении 5 секунд. По истечении этого времени операция чтения генерирует ошибку и соответственно 
происходит выход из цикла, где мы пытаемся прочитать данные от сервера. 5 секунд - довольно большой период, но в начале перед первым взаимодействием 
лучше устанавливать период побольше. И после прочтения первых 1024 байт таймаут сбрасывается до 700 миллисекунд. То есть если в течение последующих 
700 милисекунд сервер не пришлет никаких данных, то происходит выход из цикла и соответственно чтение данных заканчивается.
   </p>
   <p>
    Важно понимать роль подобных задержек, так как они позволяют сгенерировать ошибку при чтении данных. А значит мы можем получить эту ошибку и должным образом обработать ее, 
например, выйти из бесконечного цикла. Если бы мы не использовали установку таймаута, то могла бы сложиться ситуация, когда сервер ожидал данных от клиента в операции чтения, 
а клиент ожидал данных от сервера также в операции чтения. И была бы своего рода блокировка.
   </p>
   <p>
    Код сервера остается тем же, что и в прошлой теме:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"net"
)
var dict = map[string]string{ 
	"red": "красный",
	"green": "зеленый",
	"blue": "синий",
	"yellow": "желтый",
}
	
func main() {
	listener, err := net.Listen("tcp", ":4545") 
	
	if err != nil {
		fmt.Println(err) 
		return 
	} 
	defer listener.Close() 
	fmt.Println("Server is listening...")
	for { 
		conn, err := listener.Accept() 
		if err != nil { 
			fmt.Println(err) 
			conn.Close() 
			continue
		} 
		go handleConnection(conn)  // запускаем горутину для обработки запроса
	} 
}
// обработка подключения
func handleConnection(conn net.Conn) { 
	defer conn.Close()
	for {
		// считываем полученные в запросе данные
		input := make([]byte, (1024 * 4)) 
		n, err := conn.Read(input) 
		if n == 0 || err != nil {
			fmt.Println("Read error:", err)
			break
		}	 
		source := string(input[0:n])
		// на основании полученных данных получаем из словаря перевод 
		target, ok := dict[source]
		if ok == false{				// если данные не найдены в словаре
			target = "undefined"
		}
		// выводим на консоль сервера диагностическую информацию
		fmt.Println(source, "-", target)
		// отправляем данные клиенту
		conn.Write([]byte(target))
	}
}</pre>
  </div>
  <div class="item center menC">
   <h2>
    Отправка запросов по HTTP
   </h2>
   <div class="date">
    Последнее обновление: 20.01.2018
   </div>
   <p>
    Особую область применения Go представляют запросы по протоколу HTTP. 
Протокол HTTP работает поверх TCP, и технически мы можем написать приложение, которое принимает или отправляет запросы по протоколу TCP и тем самым отправлять и получать 
запросы и по протоколу HTTP. Однако в связи с тем, что данный протокол и в целом сфера веб играет большую роль, то все соответствующие функции по работе с 
http были выделены в отдельный пакет
    <a href="https://golang.org/pkg/net/http/" rel="nofollow">
     net/http
    </a>
    .
   </p>
   <p>
    Для отправки запросов в пакете net/http определен ряд функций:
   </p>
   <pre class="brush:go;">func Get(url string) (resp *Response, err error)
func Head(url string) (resp *Response, err error)
func Post(url string, contentType string, body io.Reader) (resp *Response, err error)
func PostForm(url string, data url.Values) (resp *Response, err error)</pre>
   <ul>
    <li>
     <p>
      <span class="b">
       Get()
      </span>
      : отправляет запрос GET
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       Head()
      </span>
      : отправляет запрос HEAD
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       Post()
      </span>
      : отправляет запрос POST
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       PostForm()
      </span>
      : отправляет форму в запросе POST
     </p>
    </li>
   </ul>
   <p>
    Рассмотрим выполнение самого простого запроса - запроса GET, для которого применяется одноименный метод:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"net/http"
)
func main() {
	resp, err := http.Get("https://google.com") 
	if err != nil { 
		fmt.Println(err) 
		return 
	} 
	defer resp.Body.Close()
	for true {
			
		bs := make([]byte, 1014)
		n, err := resp.Body.Read(bs)
		fmt.Println(string(bs[:n]))
		
		if n == 0 || err != nil{
			break
		}
	}
}</pre>
   <p>
    Метод
    <code>
     Get()
    </code>
    в качестве параметра принимает адрес ресурса, к которому надо выполнить запрос, и возвращает объект
    <code>
     *http.Response
    </code>
    , 
который инкапсулирует ответ. Поле Body cтруктуры http.Response представляет ответ от веб-ресурса и при этом также представляет 
интерфейс
    <code>
     io.ReadCloser
    </code>
    . А это значит, что это поле по сути является потоком для чтения, и 
мы можем считать пришедшие данные через метод Read. И кроме того, для тобо, чтобы закрыть поок, необходимо вызвать метод Close. Поэтому после запроса вызывается метод
    <code>
     defer resp.Body.Close()
    </code>
    и в цикле считываем через метод Read данные и выводим на консоль.
   </p>
   <img alt="HttpClient in Golang" src="https://metanit.com/go/tutorial/pics/8.1.png"/>
   <p>
    Поскольку в данном случае ответ от веб-ресурса все равно выводится на консоль, то мы можем сократить код:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"net/http"
	"io"
	"os"
)
func main() {
   resp, err := http.Get("https://google.com") 
   if err != nil { 
         fmt.Println(err) 
         return 
   } 
   defer resp.Body.Close() 
   io.Copy(os.Stdout, resp.Body)
}</pre>
  </div>
  <div class="item center menC">
   <h2>
    http.Client
   </h2>
   <div class="date">
    Последнее обновление: 20.01.2018
   </div>
   <p>
    Для осуществления HTTP-запросов также может применяться структура
    <span class="b">
     http.Client
    </span>
    . Чтобы отправить запрос к веб-ресурсу, можно использовать 
один из ее методов:
   </p>
   <pre class="brush:go;">func (c *Client) Do(req *Request) (*Response, error)
func (c *Client) Get(url string) (resp *Response, err error)
func (c *Client) Head(url string) (resp *Response, err error)
func (c *Client) Post(url string, contentType string, body io.Reader) (resp *Response, err error)
func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)</pre>
   <p>
    Во многом они аналогичны тем одноименным функциям (за исключением метода Do), которые определены в пакете net/http и которые были рассмотрены в прошлой теме. Например, 
выполнение самого простого запроса GET:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"net/http"
	"io"
	"os"
)
func main() { 
   client := http.Client{} 
   resp, err := client.Get("https://google.com") 
   if err != nil { 
         fmt.Println(err) 
         return 
   } 
   defer resp.Body.Close() 
   io.Copy(os.Stdout, resp.Body)
}</pre>
   <h3>
    Настройка клиента
   </h3>
   <p>
    Структура http.Client имеет ряд полей, которые позволяют настроить ее поведение:
   </p>
   <ul>
    <li>
     <p>
      <span class="b">
       Timeout
      </span>
      : устанавливает таймаут для запроса
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       Jar
      </span>
      : устанавливает куки, отправляемые в запросе
     </p>
    </li>
    <li>
     <p>
      <span class="b">
       Transport
      </span>
      : определяет механиз выполнения запроса
     </p>
    </li>
   </ul>
   <p>
    Установка таймаута:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"net/http"
	"io"
	"os"
	"time"
)
func main() { 
	client := http.Client{
		Timeout: 6 * time.Second,
	} 
	resp, err := client.Get("https://google.com") 
	if err != nil { 
		fmt.Println(err) 
		return 
	} 
	defer resp.Body.Close() 
	io.Copy(os.Stdout, resp.Body)
}</pre>
   <p>
    Свойство Timeout представляет объект
    <code>
     time.Duration
    </code>
    , и в данном случае оно равно 6 секундам.
   </p>
   <h3>
    Request
   </h3>
   <p>
    Для управления запросом и его параметрами в Go используется объект
    <span class="b">
     http.Request
    </span>
    . Он позволяет установить различные настройки, 
добавить куки, заголовки, определить тело запроса. Для создания объекта http.Request применяется функция
    <span class="b">
     http.NewRequest()
    </span>
    :
   </p>
   <pre class="brush:go;">func NewRequest(method, url string, body io.Reader) (*Request, error)</pre>
   <p>
    Функция принимает три параметра. Первый параметр - тип запроса в виде строки ("GET", "POST"). Второй параметр - адрес ресурса. Третий параметр - тело запроса.
   </p>
   <p>
    Для отправки объекта Request можно применять метод
    <span class="b">
     Do()
    </span>
    :
   </p>
   <pre class="brush:go;">Do(req *http.Request) (*http.Response, error)</pre>
   <p>
    Например:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"net/http"
	"io"
	"os"
)
func main() { 
	client := &amp;http.Client{} 
	req, err := http.NewRequest( 
         "GET", "https://google.com", nil, 
	) 
	// добавляем заголовки
	req.Header.Add("Accept", "text/html") 	// добавляем заголовок Accept
	req.Header.Add("User-Agent", "MSIE/15.0") 	// добавляем заголовок User-Agent
 
	resp, err := client.Do(req) 
	if err != nil { 
		fmt.Println(err) 
		return 
	} 
	defer resp.Body.Close() 
	io.Copy(os.Stdout, resp.Body)
}</pre>
  </div>
  <div class="item center menC">
   <h1>
    Базы данных
   </h1>
   <h2>
    Работа с реляционными база данных
   </h2>
   <div class="date">
    Последнее обновление: 31.01.2018
   </div>
   <p>
    Для работы с реляционными базами данных в языке Go применяется встроенный пакет
    <a href="https://golang.org/pkg/database/sql/" rel="nofollow">
     database/sql
    </a>
    . Однако он не используется сам по себе. Он лишь предоставляет универсальный интерфейс для работы с базами данных. 
Для работы с конкретной СУБД нам также необходим драйвер. Список доступных драйверов можно найти
    <a href="https://github.com/golang/go/wiki/SQLDrivers" rel="nofollow">
     здесь
    </a>
    . 
Однако поскольку драйвера реализуют одни и те же интерфейсы, то в принципе работа с различными СУБД будет идентична.
   </p>
   <p>
    Для того, чтобы начать работу с базой данных, необходимо открыть подключение с помощью функции
    <span class="b">
     Open()
    </span>
    :
   </p>
   <pre class="brush:go;">func Open(driverName, dataSourceName string) (*DB, error)</pre>
   <p>
    Эта функция принимает в качестве параметров имя драйвера и имя источника данных, к которому надо подключаться. Возвращает функция 
объект DB - по сути базу данных, с которой мы можем работать. Если неудалось подключить к источнику данных, то в объекте error мы сможем найти сведения об 
ошибке.
   </p>
   <p>
    Затем взаимодействие с базой данных осуществляется посредством методов объекта DB.
   </p>
   <pre class="brush:go;">func (db *DB) Exec(query string, args ...interface{}) (Result, error)
func (db *DB) Query(query string, args ...interface{}) (*Rows, error)
func (db *DB) QueryRow(query string, args ...interface{}) *Row
func (db *DB) Close() error			// закрывает подключение</pre>
   <ul>
    <li>
     <p>
      Метод
      <span class="b">
       Exec()
      </span>
      выполняет некоторое sql-выражение, которое передается через первый параметр, не возвращая никакого результата. 
Метод также принимает дополнительные параметры, с помощью которых можно передать значения в выполняемое sql-выражение. Например, 
абстрактная операция добавления данных в БД, которая предполагает выполнение команды INSERT:
     </p>
     <pre class="brush:go;">result, err := db.Exec("INSERT INTO Products (model, company, price) VALUES ('iPhone X', 'Apple', 72000)")</pre>
     <p>
      Способ вставки дополнительных параметров в SQL-выражение зависит от конкретного драйвера. Также этот метод подходит для выполнения команд UPDATE (обновление) и DELETE (удаление).
     </p>
     <p>
      Метод возвращает объект
      <code>
       Result
      </code>
      . Это интерфейс определяет два метода:
     </p>
     <pre class="brush:go;">LastInsertId() (int64, error)	// возвращает id последней строки, которая была добавлена/обновлена/удалена
RowsAffected() (int64, error)	// возвращает количество затронутых строк</pre>
    </li>
    <li>
     <p>
      Метод
      <span class="b">
       Query()
      </span>
      для выполнения запроса, который возвращает какие-либо данные. Обычно это запросы, которые содержат команду SELECT.
     </p>
     <pre class="brush:go;">rows, err := db.Query("SELECT name FROM users WHERE age=23")</pre>
     <p>
      Результатом запроса является объект
      <span class="b">
       *Rows
      </span>
      - по сути набор строк. С помощью ряда его методов можно извлечь полученные данные:
     </p>
     <pre class="brush:go;">func (rs *Rows) Columns() ([]string, error)		// возвращает названия столбцов набора
func (rs *Rows) Next() bool						// возвращает true если в наборе есть еще одна строка и переходит к ней
func (rs *Rows) Scan(dest ...interface{}) error		// считывает данные строки в переменные
func (rs *Rows) Close() error					// закрывает объект Rows для дальнейшего чтения</pre>
     <p>
      Общий принцип чтения набора строк выглядит примерно следующим образом:
     </p>
     <pre class="brush:go;">rows, err := db.Query("SELECT ...")
...
defer rows.Close()
for rows.Next() {
    var id int
    var name string
    rows.Scan(&amp;id, &amp;name)
    fmt.Println(id, name)
}</pre>
     <p>
      Вначале выполняем запрос к базе данных с помощью метода
      <code>
       db.Query
      </code>
      , затем с помощью метода
      <code>
       Next()
      </code>
      последовательно считываем все строки из набора. 
Если строк в наборе нет, то метод возвращает
      <code>
       false
      </code>
      , и происходит ыход из цикла. Если строки еще есть, то указатель *Rows переходит к следующей строке. 
И затем мы можем считать в переменные с помощью метода
      <code>
       Scan()
      </code>
      данные из текущей строки.
     </p>
    </li>
    <li>
     <p>
      Метод
      <span class="b">
       QueryRow()
      </span>
      возвращает одну строку в виде объекта
      <span class="b">
       *Row
      </span>
      . Как правило, этот метод применяется для получение единичного объекта, 
например, по id. Этот объект имеет метод
      <code>
       Scan()
      </code>
      , который позволяет извлечь данные из строки:
     </p>
     <pre class="brush:go;">func (r *Row) Scan(dest ...interface{}) error</pre>
    </li>
   </ul>
   <p>
    Также стоит отметить, что язык Go поддерживает создание запросов с помощью объекта
    <span class="b">
     Stmt
    </span>
    , в который можно вводить различные данные и который повышает производительность. 
И также в Go имеется поддержка транзакций в виде объекта
    <span class="b">
     Tx
    </span>
    .
   </p>
   <p>
    Все эти вещи по разному реализуются в различных драйверах для конкретных систем управления базами данных. Но общие принципы будут одни и те же. То есть общая 
структура работы с различными база данных благодаря единому интерфейсу будут совпадать.
   </p>
  </div>
  <div class="item center menC">
   <h2>
    MySQL
   </h2>
   <div class="date">
    Последнее обновление: 31.01.2018
   </div>
   <p>
    Для работы с MySQL будем использовать драйвер
    <a href="https://github.com/go-sql-driver/mysql/" rel="nofollow">
     Go MySQL Driver
    </a>
    . 
Прежде всего нам надо добавить данный драйвер к переменной $GOPATH. Для этого выполним в командной строке/терминале следующую команду:
   </p>
   <pre class="brush:go;">go get github.com/go-sql-driver/mysql</pre>
   <p>
    Вначале создадим на сервере MySQL базу данных productdb и в ней таблицу products. Для этого можно использовать следующие выражений SQL
   </p>
   <pre class="brush:sql;">create database productdb;
use productdb;
create table products (
	id int auto_increment primary key,
	model varchar(30) not null,
	company varchar(30) not null,
	price int not null
)</pre>
   <p>
    То есть база данных productdb, в ней есть таблица products, которая будет хранить информацию о товарах, будет 4 столбца: id - идентификатор каждой записи, model - название товара, company - производитель товара и price - цена товара.
   </p>
   <h3>
    Добавление данных
   </h3>
   <p>
    Созданная база данных пуста, поэтому добавим в нее какие-нибудь данные:
   </p>
   <pre class="brush:go;">package main
import (
	"database/sql"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
)

func main() { 
	db, err := sql.Open("mysql", "root:password@/productdb")
	
	if err != nil {
		panic(err)
	} 
	defer db.Close()
	
	result, err := db.Exec("insert into productdb.Products (model, company, price) values (?, ?, ?)", 
		"iPhone X", "Apple", 72000)
	if err != nil{
		panic(err)
	}
	fmt.Println(result.LastInsertId())	// id добавленного объекта
	fmt.Println(result.RowsAffected())	// количество затронутых строк
}</pre>
   <p>
    Вначале подключаем все нужные нам пакеты. Для работы с реляционной базой данных необходим пакет "database/sql". И так как мы используем mysql, 
то также подключаем пакет "github.com/go-sql-driver/mysql", причем обратите внимание, что перед ним стоит знак подчеркивания. Этот знак позволяет при загрузке 
пакета инициализировать его с помощью вызова функции init.
   </p>
   <p>
    Далее открываем подключение функцией Open:
   </p>
   <pre class="brush:go;">sql.Open("mysql", "root:password@/productdb")</pre>
   <p>
    Первый аргумент функции - название драйвера, в данном случае это "mysql". Второй параметр имеет форму "логин:пароль@/база_данных". Логин и пароль должны быть те, 
которые были указаны для mysql при его установке. В моем случае логин - root, а пароль - password. Название базы данных -productdb - та, которая была создана выше.
   </p>
   <p>
    Эта функция возвращает объект базы данных - DB. И для добавления данных у этого объекта вызывается метод
    <span class="b">
     Exec()
    </span>
    :
   </p>
   <pre class="brush:go;">result, err := db.Exec("insert into productdb.Products (model, company, price) values (?, ?, ?)", 
		"iPhone X", "Apple", 72000)</pre>
   <p>
    Первый аргумент функции - это sql-выражение, которое добавляет строку в таблицу Products. Знаки вопроса в этом выражении представляют плейсхолдеры, 
вместо которых вставляются значения, которые передаются через второй, третий и последующие параметры. То есть в таблице Products четыре столбца, но один из них 
автогенерируемый - id. Поэтому передаем три значения - для столбцов model, company и price. Поэтому в выражении три знака вопроса и соответственно функция принимает три дополнительных 
параметра. Все дополнительные параметры передаются в sql-выражение на место плейсхолдеров по позиции - первый параметр вместо первого плейсхолдера и так далее.
   </p>
   <p>
    Результат выполнения функции попадает в переменную result, которая хранит результат выполнения операции в базе данных. В частности, через метод
    <span class="b">
     result.LastInsertId()
    </span>
    мы можем получить id последнего добавленного объекта, а с помощью метода
    <span class="b">
     result.RowsAffected()
    </span>
    - количество добавленных строк.
   </p>
   <p>
    И при выполнении данного скрипта получим следующие результаты:
   </p>
   <img alt="Добавление в базу данных MySQL в языке Go" src="https://metanit.com/go/tutorial/pics/11.1.png"/>
   <p>
    При этом необязательно определять все добавляемые данные через параметры, можно ввести их напрямую в sql-выражение:
   </p>
   <pre class="brush:go;">result, err := db.Exec("insert into productdb.Products (model, company, price) values ('Pixel 2', 'Google', 64000)")</pre>
   <h3>
    Получение данных
   </h3>
   <p>
    Теперь получим ранее добавленные данные:
   </p>
   <pre class="brush:go;">package main
import (
	"database/sql"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
)

type product struct{
	id int
	model string
	company string
	price int
}
func main() { 
	db, err := sql.Open("mysql", "root:password@/productdb")
	
	if err != nil {
		panic(err)
	} 
	defer db.Close()
	rows, err := db.Query("select * from productdb.Products")
	if err != nil {
		panic(err)
	}
	defer rows.Close()
	products := []product{}
	
	for rows.Next(){
		p := product{}
		err := rows.Scan(&amp;p.id, &amp;p.model, &amp;p.company, &amp;p.price)
		if err != nil{
			fmt.Println(err)
			continue
		}
		products = append(products, p)
	}
	for _, p := range products{
		fmt.Println(p.id, p.model, p.company, p.price)
	}
}</pre>
   <p>
    Для работы с данными здесь определена структура product, которая соответствует данным в таблице Products.
   </p>
   <p>
    Для получения данных вызывается метод
    <span class="b">
     Query()
    </span>
    :
   </p>
   <pre class="brush:go;">rows, err := db.Query("select * from productdb.Products")</pre>
   <p>
    Этот метод в качестве параметра принимает sql-выражение SELECT на получение всех данных из таблицы Products. Результат выборки попадает в 
переменную rows, которая представляет указатель на структуру
    <span class="b">
     Rows
    </span>
    . И с помощью метода
    <span class="b">
     rows.Next()
    </span>
    мы можем последовательно перебрать все строки в полученном наборе:
   </p>
   <pre class="brush:go;">for rows.Next(){
	p := product{}
	err := rows.Scan(&amp;p.id, &amp;p.model, &amp;p.company, &amp;p.price)
	if err != nil{
		fmt.Println(err)
		continue
	}
	products = append(products, p)
}</pre>
   <p>
    Тип Rows определяет метод Scan, с помощью которого можно считать все полученные данные в переменные. Например, здесь считываем данные в структуру Product и затем 
добавляем ее в срез. Поскольку мы получаем все данные - все четыре столбца, то соответственно в Scan передается адреса четырех переменных.
   </p>
   <p>
    После прочтения данных в срез мы можем делать с ними все что угодно, например, вывести на консоль:
   </p>
   <img alt="Получение данных из базы данных MySQL в языке Go" src="https://metanit.com/go/tutorial/pics/11.2.png"/>
   <p>
    В методе Query мы можем указывать дополнительные параметры. Например, получим товары, у которых цена больше 70000:
   </p>
   <pre class="brush:go;">rows, err := db.Query("select * from productdb.Products where price &gt; ?", 70000)</pre>
   <p>
    Если надо получить только одну строку, то можно использовать метод
    <span class="b">
     QueryRow()
    </span>
    :
   </p>
   <pre class="brush:go;">row := db.QueryRow("select * from productdb.Products where id = ?", 2)
prod := product{}
err = row.Scan(&amp;prod.id, &amp;prod.model, &amp;prod.company, &amp;prod.price)
if err != nil{
	panic(err)
}
fmt.Println(prod.id, prod.model, prod.company, prod.price)</pre>
   <h3>
    Обновление
   </h3>
   <p>
    Для обновления данных применяется метод Exec:
   </p>
   <pre class="brush:go;">package main
import (
	"database/sql"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
)

func main() { 
	db, err := sql.Open("mysql", "root:password@/productdb")
	
	if err != nil {
		panic(err)
	} 
	defer db.Close()
	// обновляем строку с id=1
	result, err := db.Exec("update productdb.Products set price = ? where id = ?", 69000, 1)
	if err != nil{
		panic(err)
	}
	fmt.Println(result.LastInsertId())
	fmt.Println(result.RowsAffected())
}</pre>
   <h3>
    Удаление
   </h3>
   <p>
    Для удаления также применяется метод Exec:
   </p>
   <pre class="brush:go;">package main
import (
	"database/sql"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
)

func main() { 
	db, err := sql.Open("mysql", "root:password@/productdb")
	
	if err != nil {
		panic(err)
	} 
	defer db.Close()
	result, err := db.Exec("delete from productdb.Products where id = 1")
	if err != nil{
		panic(err)
	}
	fmt.Println(result.LastInsertId())	// id последнего удаленого объекта
	fmt.Println(result.RowsAffected())	// количество затронутых строк
}</pre>
  </div>
  <div class="item center menC">
   <h2>
    PostgreSQL
   </h2>
   <div class="date">
    Последнее обновление: 31.01.2018
   </div>
   <p>
    Для работы с PostgreSQL в Go мы можем применять различные драйверы, но в данном случае мы будем использовать
    <a href="https://github.com/lib/pq" rel="nofollow">
     Pure Go Postgres driver
    </a>
    .
   </p>
   <p>
    Поэтому  начале перейдем в командную строку/терминал и установим данный драйвер с помощью команды
   </p>
   <div class="console">
    <pre class="consoletext">go get github.com/lib/pq</pre>
   </div>
   <p>
    Пусть на сервере PostgreSQL будет база данных
    <span class="b">
     productdb
    </span>
    , в которой есть таблица Products, описываемая следующим скриптом:
   </p>
   <pre class="brush:sql;">CREATE TABLE Products (
    id    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    model  varchar(30) NOT NULL,
    company varchar(30) NOT NULL,
    price integer NOT NULL
);</pre>
   <p>
    То есть в таблице будет четыре столбца: id, model, company, price.
   </p>
   <h3>
    Открытие подключения
   </h3>
   <p>
    Для открытия соединения с базой данных в функцию
    <span class="b">
     sql.Open()
    </span>
    передается имя драйвера "postgres" и строка подключения:
   </p>
   <pre class="brush:go;">connStr := "user=postgres password=mypass dbname=productdb sslmode=disable"
db, err := sql.Open("postgres", connStr)</pre>
   <p>
    Строка подключения инкапсулирует следующие параметры:
    <code>
     user
    </code>
    (логин на сервере PostgreSQL),
    <code>
     password
    </code>
    (пароль этого пользователя),
    <code>
     dbname
    </code>
    (имя базы данных),
    <code>
     sslmode
    </code>
    (режим работы с SSL). В моем случае логин - postgres (логин по умолчанию на сервере), 
пароль - mypass, имя базы данных - productdb (которая была создана выше) и ssl отключен (значение disable).
   </p>
   <p>
    В результате установки подлючения метод db.Open возвратить объект
    <code>
     *DB
    </code>
    , через который можно будет взаимодействовать в базой данных.
   </p>
   <p>
    Это не все возможные параметры. Полный список параметров для строки подключения и их значения можно посмотреть в
    <a href="https://godoc.org/github.com/lib/pq" rel="nofollow">
     документации
    </a>
    .
   </p>
   <h3>
    Добавление данных
   </h3>
   <p>
    Для добавления используется метод
    <span class="b">
     Exec()
    </span>
    :
   </p>
   <pre class="brush:go;">package main
import (
	"database/sql"
	"fmt"
	_ "github.com/lib/pq"
)

func main() { 

	connStr := "user=postgres password=mypass dbname=productdb sslmode=disable"
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		panic(err)
	} 
	defer db.Close()
	
	result, err := db.Exec("insert into Products (model, company, price) values ('iPhone X', $1, $2)", 
		"Apple", 72000)
	if err != nil{
		panic(err)
	}
	fmt.Println(result.LastInsertId())	// не поддерживается
	fmt.Println(result.RowsAffected())	// количество добавленных строк
}</pre>
   <p>
    Выполняемое sql-выражение может получать значения через дополнительные параметры метода
    <code>
     db.Exec()
    </code>
    . В самом sql-выражении такие 
значения представлены плейсхолдерами $1, $2 и так далее, вместо которых вставляются значения дополнительных параметров метода db.Exec.
   </p>
   <p>
    Стоит обратить внимание, что этот драйвер не поддерживает метод
    <code>
     result.LastInsertId()
    </code>
    , который возвращает id последнего добавленного объекта:
   </p>
   <img alt="Добавление в базу данных PostgreSQL в языке Go" src="https://metanit.com/go/tutorial/pics/11.3.png"/>
   <p>
    Если нам обязательно нужно получить id добавленного объекта, то мы можем использовать метод
    <span class="b">
     db.QueryRow()
    </span>
    , 
который выполняет запрос и возвращает определенный объект:
   </p>
   <pre class="brush:go;">var id int
db.QueryRow("insert into Products (model, company, price) values ('Mate 10 Pro', $1, $2) returning id", 
	"Huawei", 35000).Scan(&amp;id)
fmt.Println(id)</pre>
   <p>
    В само sql выражение вводится подвыражение "returning id". И с помощью метода
    <code>
     Scan()
    </code>
    полученное значение считывается в переменную id.
   </p>
   <h3>
    Получение данных
   </h3>
   <p>
    Для получения данных применяется метод
    <code>
     db.Query()
    </code>
    , который возващает набор строк, либо
    <code>
     db.QueryRow()
    </code>
    , который возвращает 
одну строку:
   </p>
   <pre class="brush:go;">package main
import (
	"database/sql"
	"fmt"
	_ "github.com/lib/pq"
)

type product struct{
	id int
	model string
	company string
	price int
}
func main() { 

	connStr := "user=postgres password=mypass dbname=productdb sslmode=disable"
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		panic(err)
	} 
	defer db.Close()
	
	rows, err := db.Query("select * from Products")
	if err != nil {
		panic(err)
	}
	defer rows.Close()
	products := []product{}
	
	for rows.Next(){
		p := product{}
		err := rows.Scan(&amp;p.id, &amp;p.model, &amp;p.company, &amp;p.price)
		if err != nil{
			fmt.Println(err)
			continue
		}
		products = append(products, p)
	}
	for _, p := range products{
		fmt.Println(p.id, p.model, p.company, p.price)
	}
}</pre>
   <p>
    Для работы с данными здесь определена структура product, которая соответствует данным в таблице Products.
   </p>
   <p>
    Для получения данных вызывается метод
    <span class="b">
     Query()
    </span>
    :
   </p>
   <pre class="brush:go;">rows, err := db.Query("select * from Products")</pre>
   <p>
    Этот метод в качестве параметра принимает sql-выражение SELECT на получение всех данных из таблицы Products. Результат выборки попадает в 
переменную rows, которая представляет указатель на структуру
    <span class="b">
     Rows
    </span>
    . И с помощью метода
    <span class="b">
     rows.Next()
    </span>
    мы можем последовательно перебрать все строки в полученном наборе:
   </p>
   <pre class="brush:go;">for rows.Next(){
	p := product{}
	err := rows.Scan(&amp;p.id, &amp;p.model, &amp;p.company, &amp;p.price)
	if err != nil{
		fmt.Println(err)
		continue
	}
	products = append(products, p)
}</pre>
   <p>
    Тип Rows определяет метод Scan, с помощью которого можно считать все полученные данные в переменные. Например, здесь считываем данные в структуру Product и затем 
добавляем ее в срез. Поскольку мы получаем все данные - все четыре столбца, то соответственно в Scan передается адреса четырех переменных.
   </p>
   <p>
    После прочтения данных в срез мы можем делать с ними все что угодно, например, вывести на консоль:
   </p>
   <img alt="Получение данных из базы данных PostgreSQL в языке Go" src="https://metanit.com/go/tutorial/pics/11.4.png"/>
   <p>
    В методе Query мы можем указывать дополнительные параметры. Например, получим товары, у которых цена больше 70000:
   </p>
   <pre class="brush:go;">rows, err := db.Query("select * from Products where price &gt; $1", 70000)</pre>
   <p>
    Если надо получить только одну строку, то можно использовать метод
    <span class="b">
     QueryRow()
    </span>
    :
   </p>
   <pre class="brush:go;">row := db.QueryRow("select * from Products where id = $1", 2)
prod := product{}
err = row.Scan(&amp;prod.id, &amp;prod.model, &amp;prod.company, &amp;prod.price)
if err != nil{
	panic(err)
}
fmt.Println(prod.id, prod.model, prod.company, prod.price)</pre>
   <h3>
    Обновление
   </h3>
   <p>
    Для обновления данных применяется метод Exec:
   </p>
   <pre class="brush:go;">package main
import (
	"database/sql"
	"fmt"
	_ "github.com/lib/pq"
)
func main() { 

	connStr := "user=postgres password=mypass dbname=productdb sslmode=disable"
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		panic(err)
	} 
	defer db.Close()
	
	// обновляем строку с id=1
	result, err := db.Exec("update Products set price = $1 where id = $2", 69000, 1)
	if err != nil{
		panic(err)
	}
	fmt.Println(result.RowsAffected())	// количество обновленных строк
}</pre>
   <h3>
    Удаление
   </h3>
   <p>
    Для удаления также применяется метод Exec:
   </p>
   <pre class="brush:go;">package main
import (
	"database/sql"
	"fmt"
	_ "github.com/lib/pq"
)
func main() { 

	connStr := "user=postgres password=mypass dbname=productdb sslmode=disable"
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		panic(err)
	} 
	defer db.Close()
	
	// удаляем строку с id=2
	result, err := db.Exec("delete from Products where id = $1", 2)
	if err != nil{
		panic(err)
	}
	fmt.Println(result.RowsAffected())	// количество удаленных строк
}</pre>
  </div>
  <div class="item center menC">
   <h2>
    SQLite
   </h2>
   <div class="date">
    Последнее обновление: 31.01.2018
   </div>
   <p>
    Для работы с SQLite в Go нам потребуется драйвер
    <a href="https://github.com/mattn/go-sqlite3" rel="nofollow">
     go-sqlite3
    </a>
    . Для использования 
драйвера вначале установим его, выполнив в командной строке/терминале следующую команду:
   </p>
   <div class="console">
    <pre class="consoletext">go get github.com/mattn/go-sqlite3</pre>
   </div>
   <p>
    Пусть в папке со скриптом программы на Go у нас будет создана база данных SQLite, которая называется
    <span class="b">
     store.db
    </span>
    , и в ней будет таблица products, которая описывается следующим скриптом:
   </p>
   <pre class="brush:sql;">CREATE TABLE products(
  id INTEGER PRIMARY KEY AUTOINCREMENT, 
  model TEXT,
  company TEXT,
  price INTEGER
);</pre>
   <img alt="Работа с базой данных SQLite в Go" src="https://metanit.com/go/tutorial/pics/11.5.png"/>
   <h3>
    Открытие подключения
   </h3>
   <p>
    Для открытия соединения с базой данных в функцию
    <span class="b">
     sql.Open()
    </span>
    передается имя драйвера "sqlite3" и путь к файлу базы данных:
   </p>
   <pre class="brush:go;">db, err := sql.Open("sqlite3", "store.db")</pre>
   <p>
    В результате установки подлючения метод db.Open возвратить объект
    <code>
     *DB
    </code>
    , через который можно будет взаимодействовать в базой данных.
   </p>
   <h3>
    Добавление данных
   </h3>
   <p>
    Для добавления используется метод
    <span class="b">
     Exec()
    </span>
    объекта DB:
   </p>
   <pre class="brush:go;">package main
import (
	"database/sql"
	"fmt"
	_ "github.com/mattn/go-sqlite3"
)
func main() { 

	db, err := sql.Open("sqlite3", "store.db")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	result, err := db.Exec("insert into products (model, company, price) values ('iPhone X', $1, $2)", 
		"Apple", 72000)
	if err != nil{
		panic(err)
	}
	fmt.Println(result.LastInsertId())	// id последнего добавленного объекта
	fmt.Println(result.RowsAffected())	// количество добавленных строк
	
}</pre>
   <p>
    Через дополнительные параметры метода
    <code>
     db.Exec()
    </code>
    можно передавать значения выполняемому sql-выражению через 
плейхолдеры $1, $2 и так далее, вместо которых вставляются значения дополнительных параметров метода db.Exec.
   </p>
   <p>
    У результата операции есть метод
    <code>
     result.LastInsertId()
    </code>
    , который возвращает id последнего добавленного объекта, и метод
    <code>
     result.RowsAffected()
    </code>
    , который позволяет получить 
количество добавленных строк:
   </p>
   <img alt="Добавление в базу данных SQLite в языке Go" src="https://metanit.com/go/tutorial/pics/11.6.png"/>
   <h3>
    Получение данных
   </h3>
   <p>
    Для получения данных применяется метод
    <code>
     db.Query()
    </code>
    , который возвращает набор строк, либо
    <code>
     db.QueryRow()
    </code>
    , который возвращает 
одну строку:
   </p>
   <pre class="brush:go;">package main
import (
	"database/sql"
	"fmt"
	_ "github.com/mattn/go-sqlite3"
)

type product struct{
	id int
	model string
	company string
	price int
}
func main() { 

	db, err := sql.Open("sqlite3", "store.db")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	rows, err := db.Query("select * from Products")
	if err != nil {
		panic(err)
	}
	defer rows.Close()
	products := []product{}
	
	for rows.Next(){
		p := product{}
		err := rows.Scan(&amp;p.id, &amp;p.model, &amp;p.company, &amp;p.price)
		if err != nil{
			fmt.Println(err)
			continue
		}
		products = append(products, p)
	}
	for _, p := range products{
		fmt.Println(p.id, p.model, p.company, p.price)
	}
}</pre>
   <p>
    Для работы с данными здесь определена структура product, которая соответствует данным в таблице Products.
   </p>
   <p>
    Для получения данных вызывается метод
    <span class="b">
     Query()
    </span>
    :
   </p>
   <pre class="brush:go;">rows, err := db.Query("select * from Products")</pre>
   <p>
    Этот метод в качестве параметра принимает sql-выражение SELECT на получение всех данных из таблицы Products. Результат выборки попадает в 
переменную rows, которая представляет указатель на структуру
    <span class="b">
     Rows
    </span>
    . И с помощью метода
    <span class="b">
     rows.Next()
    </span>
    мы можем последовательно перебрать все строки в полученном наборе:
   </p>
   <pre class="brush:go;">for rows.Next(){
	p := product{}
	err := rows.Scan(&amp;p.id, &amp;p.model, &amp;p.company, &amp;p.price)
	if err != nil{
		fmt.Println(err)
		continue
	}
	products = append(products, p)
}</pre>
   <p>
    Тип Rows определяет метод Scan, с помощью которого можно считать все полученные данные в переменные. Например, здесь считываем данные в структуру Product и затем 
добавляем ее в срез. Поскольку мы получаем все данные - все четыре столбца, то соответственно в Scan передается адреса четырех переменных.
   </p>
   <p>
    После прочтения данных в срез мы можем делать с ними все что угодно, например, вывести на консоль:
   </p>
   <img alt="Получение данных из базы данных SQLite в языке Go" src="https://metanit.com/go/tutorial/pics/11.7.png"/>
   <p>
    В методе Query мы можем указывать дополнительные параметры. Например, получим товары, у которых цена больше 70000:
   </p>
   <pre class="brush:go;">rows, err := db.Query("select * from Products where price &gt; $1", 70000)</pre>
   <p>
    Если надо получить только одну строку, то можно использовать метод
    <span class="b">
     QueryRow()
    </span>
    :
   </p>
   <pre class="brush:go;">row := db.QueryRow("select * from Products where id = $1", 2)
prod := product{}
err = row.Scan(&amp;prod.id, &amp;prod.model, &amp;prod.company, &amp;prod.price)
if err != nil{
	panic(err)
}
fmt.Println(prod.id, prod.model, prod.company, prod.price)</pre>
   <h3>
    Обновление
   </h3>
   <p>
    Для обновления данных применяется метод Exec:
   </p>
   <pre class="brush:go;">package main
import (
	"database/sql"
	"fmt"
	_ "github.com/mattn/go-sqlite3"
)
func main() { 

	db, err := sql.Open("sqlite3", "store.db")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	
	// обновляем строку с id=1
	result, err := db.Exec("update Products set price = $1 where id = $2", 69000, 1)
	if err != nil{
		panic(err)
	}
	fmt.Println(result.RowsAffected())	// количество обновленных строк
}</pre>
   <h3>
    Удаление
   </h3>
   <p>
    Для удаления также применяется метод Exec:
   </p>
   <pre class="brush:go;">package main
import (
	"database/sql"
	"fmt"
	_ "github.com/mattn/go-sqlite3"
)
func main() { 

	db, err := sql.Open("sqlite3", "store.db")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	
	// удаляем строку с id=1
	result, err := db.Exec("delete from Products where id = $1", 1)
	if err != nil{
		panic(err)
	}
	fmt.Println(result.RowsAffected())	// количество удаленных строк
}</pre>
  </div>
  <div class="item center menC">
   <h2>
    MongoDB
   </h2>
   <div class="date">
    Последнее обновление: 31.01.2018
   </div>
   <p>
    MongoDB не является реляционный СУБД, но тем не менее это тоже довольно распространенная система управления базами данных, которую можно использовать в Go.
   </p>
   <p>
    Для работы с MongoDB нам потребуется драйвер
    <a href="https://labix.org/mgo" rel="nofollow">
     mgo
    </a>
    .
   </p>
   <p>
    Вначале установим драйвер, выполнив в командной строке/терминале следующую команду:
   </p>
   <div class="console">
    <pre class="consoletext">go get gopkg.in/mgo.v2</pre>
   </div>
   <h3>
    Подключение
   </h3>
   <p>
    Для подключения к серверу MongoDB необходимо использовать функцию
    <span class="b">
     mgo.Dial()
    </span>
    , в которую передается адрес сервера:
   </p>
   <pre class="brush:go;">func Dial(url string) (*Session, error)</pre>
   <p>
    Например, подключение к серверу на локальном компьютере:
   </p>
   <pre class="brush:go;">session, err := mgo.Dial("mongodb://127.0.0.1")</pre>
   <p>
    Функция возвращает указатель на объект
    <span class="b">
     Session
    </span>
    , который представляет текущую сессию.
   </p>
   <p>
    Используя метод
    <span class="b">
     DB
    </span>
    данного объекта, мы можем получить указатель на объект
    <span class="b">
     Database
    </span>
    , который представляет конкретную базу данных на сервере.
   </p>
   <pre class="brush:go;">func (s *Session) DB(name string) *Database</pre>
   <p>
    Все данные в базах данных MongoDB структурированы по коллекциям. Фактически коллекция - это аналог таблицы в реляционных базах данных, представлена типом
    <span class="b">
     Collection
    </span>
    . И чтобы получить обратиться к нужной коллекции, 
необходимо использовать метод
    <span class="b">
     C()
    </span>
    :
   </p>
   <pre class="brush:go;">func (db *Database) C(name string) *Collection</pre>
   <p>
    Например, получим коллекцию "products", которая расположена в базе данных "productdb":
   </p>
   <pre class="brush:go;">// открываем соединение
session, err := mgo.Dial("mongodb://127.0.0.1")
if err != nil {
	panic(err)
}
defer session.Close()
	
// получаем коллекцию products в базе данных productdb
productCollection := session.DB("productdb").C("products")</pre>
   <p>
    Получив коллекцию, мы сможем добавлять, получать данные и проводить с ними иные операции. И по завершении работы с сервером необходимо закрыть подключение методом
    <code>
     Close()
    </code>
    .
   </p>
   <h3>
    Добавление данных
   </h3>
   <p>
    Для добавления данных в коллекцию применяется метод
    <span class="b">
     Insert()
    </span>
    объекта Collection:
   </p>
   <pre class="brush:go;">func (c *Collection) Insert(docs ...interface{}) error</pre>
   <p>
    Этот метод принимает неопределенное количество добавляемых в коллекцию объектов.
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)
type Product struct{
	Id bson.ObjectId `bson:"_id"`
	Model string `bson:"model"`
	Company string `bson:"company"`
	Price int `bson:"price"`
}
func main() { 

	// открываем соединение
	session, err := mgo.Dial("mongodb://127.0.0.1")
	if err != nil {
		panic(err)
	}
	defer session.Close()
	
	// получаем коллекцию
	productCollection := session.DB("productdb").C("products")
	
	p1 := ∏{Id:bson.NewObjectId(), Model:"iPhone 8", Company:"Apple", Price:64567}
	// добавляем один объект
	err = productCollection.Insert(p1)
	if err != nil{
		fmt.Println(err)
	}
	
	p2 := ∏{Id:bson.NewObjectId(), Model:"Pixel 2", Company:"Google", Price:58000}
	p3 := ∏{Id:bson.NewObjectId(), Model:"Xplay7", Company:"Vivo", Price:49560}
	// добавляем два объекта
	err = productCollection.Insert(p2, p3)
	if err != nil{
		fmt.Println(err)
	}
}</pre>
   <p>
    Прежде всего вначале импортируем два пакета драйвера, которые содержат весь необходимый нам функционал:
   </p>
   <pre class="brush:go;">"gopkg.in/mgo.v2"
"gopkg.in/mgo.v2/bson"</pre>
   <p>
    Для представления данных здесь определена структура Product. Определение каждой переменной структуры кроме названия и типа данных содержит название поля в коллекции, с 
которым данная переменная будет сопоставляться. Например,
   </p>
   <pre class="brush:go;">Model string `bson:"model"`</pre>
   <p>
    Переменная Model будет сопоставляться с полем "model" в коллекции. Причем между названием переменной и поля коллекции необязательно должно быть соответствие.
   </p>
   <p>
    Также стоит отметить, что идентификатор объекта в MongoDB представляет специальный тип
    <span class="b">
     bson.ObjectId
    </span>
    , а в базе данных 
ему соответствует поле "_id".
   </p>
   <p>
    Для добавления создаем три объекта - фактически три указателя на объекты Product. Для создания уникального идентификатора применяется функция
    <span class="b">
     bson.NewObjectId()
    </span>
    . Затем добавляем объекты в коллекцию:
   </p>
   <pre class="brush:go;">err = productCollection.Insert(p1)
err = productCollection.Insert(p2, p3)</pre>
   <h3>
    Получение данных
   </h3>
   <p>
    Для получения данных из коллекции применяется метод
    <span class="b">
     Find()
    </span>
    :
   </p>
   <pre class="brush:go;">func (c *Collection) Find(query interface{}) *Query</pre>
   <p>
    В качестве параметра он принимает критерий выборки и возвращает объект
    <code>
     *Query
    </code>
    . Среди методов этого объекта следует выделить методы
    <span class="b">
     All()
    </span>
    и
    <span class="b">
     One
    </span>
    , которые возвращают соответственно все объекты выборки и один объект из выборки:
   </p>
   <pre class="brush:go;">func (q *Query) All(result interface{}) error
func (q *Query) One(result interface{}) (err error)</pre>
   <p>
    В качестве параметра оба метода принимают указатель на объект, в который будет сохраняться результат выборки.
   </p>
   <p>
    Например, получим ранее сохраненные объекты:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)
type Product struct{
	Id bson.ObjectId `bson:"_id"`
	Model string `bson:"model"`
	Company string `bson:"company"`
	Price int `bson:"price"`
}
func main() { 

	// открываем соединение
	session, err := mgo.Dial("mongodb://127.0.0.1")
	if err != nil {
		panic(err)
	}
	defer session.Close()
	
	// получаем коллекцию
	productCollection := session.DB("productdb").C("products")
	// критерий выборки
	query := bson.M{}
	// объект для сохранения результата
	products := []Product{}
	productCollection.Find(query).All(&amp;products)
	
	for _, p := range products{
	
		fmt.Println(p.Model, p.Company, p.Price)
	}
}</pre>
   <p>
    Критерий выборки представляет объект
    <code>
     bson.M{}
    </code>
    . Пустой объект
    <code>
     bson.M{}
    </code>
    охватывает все документы в коллекции. Все полученные документы передаются в 
объект products. И затем данные выводятся на консоль:
   </p>
   <img alt="Работа с MongoDB в Go и mgo" src="https://metanit.com/go/tutorial/pics/11.8.png"/>
   <p>
    Также мы можем конкретизировать выборку:
   </p>
   <pre class="brush:go;">query := bson.M{
	"price" : bson.M{
		"$gt":50000,
	},
}
products := []Product{}
productCollection.Find(query).All(&amp;products)
	
for _, p := range products{
	
	fmt.Println(p.Model, p.Company, p.Price)
}</pre>
   <p>
    В данном случае ищем все документы, у которых поле "price" имеет значение больше 50000.
   </p>
   <img alt="Работа с базой данных MongoDB в Go" src="https://metanit.com/go/tutorial/pics/11.9.png"/>
   <h3>
    Обновление данных
   </h3>
   <p>
    Для обновления данных применяются методы
    <span class="b">
     Update()/UpdateAll()
    </span>
    объекта Collection:
   </p>
   <pre class="brush:go;">func (c *Collection) Update(selector interface{}, update interface{}) error
func (c *Collection) UpdateAll(selector interface{}, update interface{}) (info *ChangeInfo, err error)</pre>
   <p>
    Первый параметр методов выборки представляет критерий выборки документов, которые будут обновляться. Второй параметр указывает, как эти документы будут обновляться. 
Оба параметра задаются с помощью объекта
    <code>
     bson.M
    </code>
    . Однако если метод Update обновляет только один документ, который соответствует первому параметру, 
то метод UpdateAll - обновляет все элементы.
   </p>
   <p>
    Например, изменим цену смартфона "iPhone 8":
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)
type Product struct{
	Id bson.ObjectId `bson:"_id"`
	Model string `bson:"model"`
	Company string `bson:"company"`
	Price int `bson:"price"`
}
func main() { 

	// открываем соединение
	session, err := mgo.Dial("mongodb://127.0.0.1")
	if err != nil {
		panic(err)
	}
	defer session.Close()
	
	// получаем коллекцию
	productCollection := session.DB("productdb").C("products")
	
	// обновляем данные	
	err = productCollection.Update(bson.M{"model": "iPhone 8"}, bson.M{"$set":bson.M{"price":45000}})	
	if err != nil{
		fmt.Println(err)
	}
	
	products := []Product{}
	productCollection.Find(bson.M{}).All(&amp;products)
	
	for _, p := range products{
	
		fmt.Println(p.Model, p.Company, p.Price)
	}
}</pre>
   <p>
    Первый аргумент метода Update -
    <code>
     bson.M{"model": "iPhone 8"}
    </code>
    указывает, что выбираются все элементы, у которых поле "model" равно 
"iPhone 8". Второй аргумент -
    <code>
     bson.M{"$set":bson.M{"price":45000}}
    </code>
    с помощью параметра
    <code>
     $set
    </code>
    устанавливает, какие значения будут иметь те или иные поля (в данном случае поле "price").
   </p>
   <img alt="Обновление документов в базе данных MongoDB в языке Go" src="https://metanit.com/go/tutorial/pics/11.10.png"/>
   <h3>
    Удаление документов
   </h3>
   <p>
    Для удаления документов из коллекции применяется методы
    <span class="b">
     Remove()/RemoveAll()
    </span>
    объекта Collection:
   </p>
   <pre class="brush:go;">func (c *Collection) Remove(selector interface{}) error
func (c *Collection) RemoveAll(selector interface{}) (info *ChangeInfo, err error)</pre>
   <p>
    Оба метода в качестве параметра принимают критерий выборки документов, которые будут удаляться. Только метод Remove удаляет только один документ из выборки, 
а метод RemoveAll удаляет все элементы выборки.
   </p>
   <p>
    Например, удалим все смартфоны компании Vivo:
   </p>
   <pre class="brush:go;">package main
import (
	"fmt"
	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)
type Product struct{
	Id bson.ObjectId `bson:"_id"`
	Model string `bson:"model"`
	Company string `bson:"company"`
	Price int `bson:"price"`
}
func main() { 

	// открываем соединение
	session, err := mgo.Dial("mongodb://127.0.0.1")
	if err != nil {
		panic(err)
	}
	defer session.Close()
	
	// получаем коллекцию
	productCollection := session.DB("productdb").C("products")
	
	// удаляем все документы с company = "Vivo"
	_, err = productCollection.RemoveAll(bson.M{"company": "Vivo"})		
	if err != nil{
		fmt.Println(err)
	}
	
	products := []Product{}
	productCollection.Find(bson.M{}).All(&amp;products)
	
	for _, p := range products{
	
		fmt.Println(p.Model, p.Company, p.Price)
	}
}</pre>
  </div>
 </body>
</html>
